// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// Alpaca's Trading API is a modern platform for algorithmic trading.
///
/// For complete documentation on the Trading API and to obtain your keys head to https://alpaca.markets/docs/api-documentation/api-v2/. Once you have your keys, head to the environments tab to quickly get started.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Get account
    ///
    /// Returns the account associated with the API key.
    ///
    /// - Remark: HTTP `GET /v2/account`.
    /// - Remark: Generated from `#/paths//v2/account/get(getAccount)`.
    public func getAccount(_ input: Operations.getAccount.Input) async throws -> Operations.getAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/account",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Account.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// All Orders
    ///
    /// Retrieves a list of orders for the account, filtered by the supplied query parameters.
    ///
    /// - Remark: HTTP `GET /v2/orders`.
    /// - Remark: Generated from `#/paths//v2/orders/get(getAllOrders)`.
    public func getAllOrders(_ input: Operations.getAllOrders.Input) async throws -> Operations.getAllOrders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAllOrders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/orders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "status",
                    value: input.query.status
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "after",
                    value: input.query.after
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nested",
                    value: input.query.nested
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAllOrders.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Order].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Order
    ///
    /// Places a new order for the given account. An order request may be rejected if the account is not authorized for trading, or if the tradable balance is insufficient to fill the order..
    ///
    /// - Remark: HTTP `POST /v2/orders`.
    /// - Remark: Generated from `#/paths//v2/orders/post(postOrder)`.
    public func postOrder(_ input: Operations.postOrder.Input) async throws -> Operations.postOrder.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postOrder.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/orders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postOrder.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Order.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 403:
                    return .forbidden(.init())
                case 422:
                    return .unprocessableContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// All Orders
    ///
    /// Attempts to cancel all open orders. A response will be provided for each order that is attempted to be cancelled. If an order is no longer cancelable, the server will respond with status 500 and reject the request.
    ///
    /// - Remark: HTTP `DELETE /v2/orders`.
    /// - Remark: Generated from `#/paths//v2/orders/delete(deleteAllOrders)`.
    public func deleteAllOrders(_ input: Operations.deleteAllOrders.Input) async throws -> Operations.deleteAllOrders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteAllOrders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/orders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 207:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteAllOrders.Output.Code207.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.CanceledOrderResponse].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code207(.init(body: body))
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Order by Order ID
    ///
    /// Retrieves a single order for the given order_id.
    ///
    /// - Remark: HTTP `GET /v2/orders/{order_id}`.
    /// - Remark: Generated from `#/paths//v2/orders/{order_id}/get(getOrderByOrderID)`.
    public func getOrderByOrderID(_ input: Operations.getOrderByOrderID.Input) async throws -> Operations.getOrderByOrderID.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getOrderByOrderID.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/orders/{}",
                    parameters: [
                        input.path.order_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nested",
                    value: input.query.nested
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOrderByOrderID.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Order.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Order
    ///
    /// Replaces a single order with updated parameters. Each parameter overrides the corresponding attribute of the existing order. The other attributes remain the same as the existing order.
    ///
    /// A success return code from a replaced order does NOT guarantee the existing open order has been replaced. If the existing open order is filled before the replacing (new) order reaches the execution venue, the replacing (new) order is rejected, and these events are sent in the trade_updates stream channel.
    ///
    /// While an order is being replaced, buying power is reduced by the larger of the two orders that have been placed (the old order being replaced, and the newly placed order to replace it). If you are replacing a buy entry order with a higher limit price than the original order, the buying power is calculated based on the newly placed order. If you are replacing it with a lower limit price, the buying power is calculated based on the old order.
    ///
    ///
    /// - Remark: HTTP `PATCH /v2/orders/{order_id}`.
    /// - Remark: Generated from `#/paths//v2/orders/{order_id}/patch(patchOrderByOrderId)`.
    public func patchOrderByOrderId(_ input: Operations.patchOrderByOrderId.Input) async throws -> Operations.patchOrderByOrderId.Output {
        try await client.send(
            input: input,
            forOperation: Operations.patchOrderByOrderId.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/orders/{}",
                    parameters: [
                        input.path.order_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.patchOrderByOrderId.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Order.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Order by Order ID
    ///
    /// Attempts to cancel an Open Order. If the order is no longer cancelable, the request will be rejected with status 422; otherwise accepted with return status 204.
    ///
    /// - Remark: HTTP `DELETE /v2/orders/{order_id}`.
    /// - Remark: Generated from `#/paths//v2/orders/{order_id}/delete(deleteOrderByOrderID)`.
    public func deleteOrderByOrderID(_ input: Operations.deleteOrderByOrderID.Input) async throws -> Operations.deleteOrderByOrderID.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteOrderByOrderID.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/orders/{}",
                    parameters: [
                        input.path.order_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 422:
                    return .unprocessableContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// All Open Positions
    ///
    /// The positions API provides information about an account’s current open positions. The response will include information such as cost basis, shares traded, and market value, which will be updated live as price information is updated. Once a position is closed, it will no longer be queryable through this API
    ///
    /// Retrieves a list of the account’s open positions
    ///
    /// - Remark: HTTP `GET /v2/positions`.
    /// - Remark: Generated from `#/paths//v2/positions/get(getAllOpenPositions)`.
    public func getAllOpenPositions(_ input: Operations.getAllOpenPositions.Input) async throws -> Operations.getAllOpenPositions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAllOpenPositions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/positions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAllOpenPositions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Position].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// All Positions
    ///
    /// Closes (liquidates) all of the account’s open long and short positions. A response will be provided for each order that is attempted to be cancelled. If an order is no longer cancelable, the server will respond with status 500 and reject the request.
    ///
    /// - Remark: HTTP `DELETE /v2/positions`.
    /// - Remark: Generated from `#/paths//v2/positions/delete(deleteAllOpenPositions)`.
    public func deleteAllOpenPositions(_ input: Operations.deleteAllOpenPositions.Input) async throws -> Operations.deleteAllOpenPositions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteAllOpenPositions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/positions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "cancel_orders",
                    value: input.query.cancel_orders
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 207:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteAllOpenPositions.Output.Code207.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.PositionClosedReponse].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code207(.init(body: body))
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Open Position
    ///
    /// Retrieves the account’s open position for the given symbol or assetId.
    ///
    /// - Remark: HTTP `GET /v2/positions/{symbol_or_asset_id}`.
    /// - Remark: Generated from `#/paths//v2/positions/{symbol_or_asset_id}/get(getOpenPosition)`.
    public func getOpenPosition(_ input: Operations.getOpenPosition.Input) async throws -> Operations.getOpenPosition.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getOpenPosition.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/positions/{}",
                    parameters: [
                        input.path.symbol_or_asset_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOpenPosition.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Position.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Position
    ///
    /// Closes (liquidates) the account’s open position for the given symbol. Works for both long and short positions.
    ///
    /// - Remark: HTTP `DELETE /v2/positions/{symbol_or_asset_id}`.
    /// - Remark: Generated from `#/paths//v2/positions/{symbol_or_asset_id}/delete(deleteOpenPosition)`.
    public func deleteOpenPosition(_ input: Operations.deleteOpenPosition.Input) async throws -> Operations.deleteOpenPosition.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteOpenPosition.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/positions/{}",
                    parameters: [
                        input.path.symbol_or_asset_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "qty",
                    value: input.query.qty
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "percentage",
                    value: input.query.percentage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteOpenPosition.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Order.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Account Portfolio History
    ///
    /// Returns timeseries data about equity and profit/loss (P/L) of the account in requested timespan.
    ///
    /// - Remark: HTTP `GET /v2/account/portfolio/history`.
    /// - Remark: Generated from `#/paths//v2/account/portfolio/history/get(getAccountPortfolioHistory)`.
    public func getAccountPortfolioHistory(_ input: Operations.getAccountPortfolioHistory.Input) async throws -> Operations.getAccountPortfolioHistory.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountPortfolioHistory.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/account/portfolio/history",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "period",
                    value: input.query.period
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "timeframe",
                    value: input.query.timeframe
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "date_end",
                    value: input.query.date_end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "extended_hours",
                    value: input.query.extended_hours
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountPortfolioHistory.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PortfolioHistory.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Watchlists
    ///
    /// Returns the list of watchlists registered under the account.
    ///
    /// - Remark: HTTP `GET /v2/watchlists`.
    /// - Remark: Generated from `#/paths//v2/watchlists/get(getWatchlists)`.
    public func getWatchlists(_ input: Operations.getWatchlists.Input) async throws -> Operations.getWatchlists.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getWatchlists.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/watchlists",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getWatchlists.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Watchlist].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Watchlist
    ///
    /// Create a new watchlist with initial set of assets.
    ///
    /// - Remark: HTTP `POST /v2/watchlists`.
    /// - Remark: Generated from `#/paths//v2/watchlists/post(postWatchlist)`.
    public func postWatchlist(_ input: Operations.postWatchlist.Input) async throws -> Operations.postWatchlist.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postWatchlist.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/watchlists",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postWatchlist.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Watchlist.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Watchlist by ID
    ///
    /// Returns a watchlist identified by the ID.
    ///
    /// - Remark: HTTP `GET /v2/watchlists/{watchlist_id}`.
    /// - Remark: Generated from `#/paths//v2/watchlists/{watchlist_id}/get(getWatchlistById)`.
    public func getWatchlistById(_ input: Operations.getWatchlistById.Input) async throws -> Operations.getWatchlistById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getWatchlistById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/watchlists/{}",
                    parameters: [
                        input.path.watchlist_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getWatchlistById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Watchlist.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add Asset to Watchlist
    ///
    /// Append an asset for the symbol to the end of watchlist asset list
    ///
    /// - Remark: HTTP `POST /v2/watchlists/{watchlist_id}`.
    /// - Remark: Generated from `#/paths//v2/watchlists/{watchlist_id}/post(addAssetToWatchlist)`.
    public func addAssetToWatchlist(_ input: Operations.addAssetToWatchlist.Input) async throws -> Operations.addAssetToWatchlist.Output {
        try await client.send(
            input: input,
            forOperation: Operations.addAssetToWatchlist.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/watchlists/{}",
                    parameters: [
                        input.path.watchlist_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.addAssetToWatchlist.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Watchlist.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Watchlist By Id
    ///
    /// Update the name and/or content of watchlist
    ///
    /// - Remark: HTTP `PUT /v2/watchlists/{watchlist_id}`.
    /// - Remark: Generated from `#/paths//v2/watchlists/{watchlist_id}/put(updateWatchlistById)`.
    public func updateWatchlistById(_ input: Operations.updateWatchlistById.Input) async throws -> Operations.updateWatchlistById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.updateWatchlistById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/watchlists/{}",
                    parameters: [
                        input.path.watchlist_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.updateWatchlistById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Watchlist.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Watchlist By Id
    ///
    /// Delete a watchlist. This is a permanent deletion.
    ///
    /// - Remark: HTTP `DELETE /v2/watchlists/{watchlist_id}`.
    /// - Remark: Generated from `#/paths//v2/watchlists/{watchlist_id}/delete(deleteWatchlistById)`.
    public func deleteWatchlistById(_ input: Operations.deleteWatchlistById.Input) async throws -> Operations.deleteWatchlistById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteWatchlistById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/watchlists/{}",
                    parameters: [
                        input.path.watchlist_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Watchlist by Name
    ///
    /// Returns a watchlist by name
    ///
    /// - Remark: HTTP `GET /v2/watchlists:by_name`.
    /// - Remark: Generated from `#/paths//v2/watchlists:by_name/get(getWatchlistByName)`.
    public func getWatchlistByName(_ input: Operations.getWatchlistByName.Input) async throws -> Operations.getWatchlistByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getWatchlistByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/watchlists:by_name",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "name",
                    value: input.query.name
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getWatchlistByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Watchlist.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add Asset to Watchlist By Name
    ///
    /// Append an asset for the symbol to the end of watchlist asset list
    ///
    /// - Remark: HTTP `POST /v2/watchlists:by_name`.
    /// - Remark: Generated from `#/paths//v2/watchlists:by_name/post(addAssetToWatchlistByName)`.
    public func addAssetToWatchlistByName(_ input: Operations.addAssetToWatchlistByName.Input) async throws -> Operations.addAssetToWatchlistByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.addAssetToWatchlistByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/watchlists:by_name",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "name",
                    value: input.query.name
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.addAssetToWatchlistByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Watchlist.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Watchlist By Name
    ///
    /// Update the name and/or content of watchlist
    ///
    /// - Remark: HTTP `PUT /v2/watchlists:by_name`.
    /// - Remark: Generated from `#/paths//v2/watchlists:by_name/put(updateWatchlistByName)`.
    public func updateWatchlistByName(_ input: Operations.updateWatchlistByName.Input) async throws -> Operations.updateWatchlistByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.updateWatchlistByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/watchlists:by_name",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "name",
                    value: input.query.name
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.updateWatchlistByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Watchlist.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Watchlist By Name
    ///
    /// Delete a watchlist. This is a permanent deletion.
    ///
    /// - Remark: HTTP `DELETE /v2/watchlists:by_name`.
    /// - Remark: Generated from `#/paths//v2/watchlists:by_name/delete(deleteWatchlistByName)`.
    public func deleteWatchlistByName(_ input: Operations.deleteWatchlistByName.Input) async throws -> Operations.deleteWatchlistByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteWatchlistByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/watchlists:by_name",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "name",
                    value: input.query.name
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Symbol from Watchlist
    ///
    /// Delete one entry for an asset by symbol name
    ///
    /// - Remark: HTTP `DELETE /v2/watchlists/{watchlist_id}/{symbol}`.
    /// - Remark: Generated from `#/paths//v2/watchlists/{watchlist_id}/{symbol}/delete(removeAssetFromWatchlist)`.
    public func removeAssetFromWatchlist(_ input: Operations.removeAssetFromWatchlist.Input) async throws -> Operations.removeAssetFromWatchlist.Output {
        try await client.send(
            input: input,
            forOperation: Operations.removeAssetFromWatchlist.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/watchlists/{}/{}",
                    parameters: [
                        input.path.watchlist_id,
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.removeAssetFromWatchlist.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Watchlist.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Account Configurations
    ///
    /// gets the current account configuration values
    ///
    /// - Remark: HTTP `GET /v2/account/configurations`.
    /// - Remark: Generated from `#/paths//v2/account/configurations/get(getAccountConfig)`.
    public func getAccountConfig(_ input: Operations.getAccountConfig.Input) async throws -> Operations.getAccountConfig.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountConfig.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/account/configurations",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountConfig.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountConfigurations.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Account Configurations
    ///
    /// Updates and returns the current account configuration values
    ///
    /// - Remark: HTTP `PATCH /v2/account/configurations`.
    /// - Remark: Generated from `#/paths//v2/account/configurations/patch(patchAccountConfig)`.
    public func patchAccountConfig(_ input: Operations.patchAccountConfig.Input) async throws -> Operations.patchAccountConfig.Output {
        try await client.send(
            input: input,
            forOperation: Operations.patchAccountConfig.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/account/configurations",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.patchAccountConfig.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountConfigurations.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get account activities of one type
    ///
    /// Returns account activity entries for many types of activities.
    ///
    /// - Remark: HTTP `GET /v2/account/activities`.
    /// - Remark: Generated from `#/paths//v2/account/activities/get(getAccountActivities)`.
    public func getAccountActivities(_ input: Operations.getAccountActivities.Input) async throws -> Operations.getAccountActivities.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountActivities.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/account/activities",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "date",
                    value: input.query.date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "after",
                    value: input.query.after
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "activity_types",
                    value: input.query.activity_types
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountActivities.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getAccountActivities.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get account activities of one type
    ///
    /// Returns account activity entries for a specific type of activity.
    ///
    /// - Remark: HTTP `GET /v2/account/activities/{activity_type}`.
    /// - Remark: Generated from `#/paths//v2/account/activities/{activity_type}/get(getAccountActivitiesByActivityType)`.
    public func getAccountActivitiesByActivityType(_ input: Operations.getAccountActivitiesByActivityType.Input) async throws -> Operations.getAccountActivitiesByActivityType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountActivitiesByActivityType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/account/activities/{}",
                    parameters: [
                        input.path.activity_type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "date",
                    value: input.query.date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "after",
                    value: input.query.after
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountActivitiesByActivityType.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getAccountActivitiesByActivityType.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Market Calendar info
    ///
    /// Returns the market calendar.
    ///
    /// - Remark: HTTP `GET /v2/calendar`.
    /// - Remark: Generated from `#/paths//v2/calendar/get(getCalendar)`.
    public func getCalendar(_ input: Operations.getCalendar.Input) async throws -> Operations.getCalendar.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getCalendar.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/calendar",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getCalendar.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Calendar].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Market Clock info
    ///
    /// The clock API serves the current market timestamp, whether or not the market is currently open, as well as the times of the next market open and close.
    ///
    /// Returns the market clock.
    ///
    /// - Remark: HTTP `GET /v2/clock`.
    /// - Remark: Generated from `#/paths//v2/clock/get(getClock)`.
    public func getClock(_ input: Operations.getClock.Input) async throws -> Operations.getClock.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getClock.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/clock",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getClock.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Clock.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
