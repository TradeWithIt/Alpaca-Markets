// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// Access Alpacaâ€™s historical and real-time US stock market and crypto data through REST API and WebSocket. There are APIs for Stock Pricing, Crypto Pricing, and News.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Get Bar data for multiple stock symbols
    ///
    /// The Multi Bars API returns aggregate historical data for multiple given ticker symbols over a specified time period.
    ///
    /// Returned results are sorted by symbol first then by Bar timestamp. This means that you are likely to see only one symbol in your first response if there are enough Bars for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Bars were found for them.
    ///
    /// - Remark: HTTP `GET /v2/stocks/bars`.
    /// - Remark: Generated from `#/paths//v2/stocks/bars/get(getBarsForMultipleStockSymbols)`.
    public func getBarsForMultipleStockSymbols(_ input: Operations.getBarsForMultipleStockSymbols.Input) async throws -> Operations.getBarsForMultipleStockSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getBarsForMultipleStockSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/bars",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "timeframe",
                    value: input.query.timeframe
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "adjustment",
                    value: input.query.adjustment
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBarsForMultipleStockSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultiBarsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Latest Bar data for multiple stock symbols
    ///
    /// The Bars API returns aggregate historical data for the requested security. Returns the latest bar data for the queried stock symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/bars/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/bars/latest/get(getLatestBarsForMultipleStockSymbols)`.
    public func getLatestBarsForMultipleStockSymbols(_ input: Operations.getLatestBarsForMultipleStockSymbols.Input) async throws -> Operations.getLatestBarsForMultipleStockSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestBarsForMultipleStockSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/bars/latest",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestBarsForMultipleStockSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestMultiBarsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Bars
    ///
    /// The Bars API returns aggregate historical data for the requested security. Returns bars for the queried stock symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/bars`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/bars/get(getBarsForStockSymbol)`.
    public func getBarsForStockSymbol(_ input: Operations.getBarsForStockSymbol.Input) async throws -> Operations.getBarsForStockSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getBarsForStockSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/{}/bars",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "timeframe",
                    value: input.query.timeframe
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "adjustment",
                    value: input.query.adjustment
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBarsForStockSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BarsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Latest Bars for Symbol
    ///
    /// The Bars API returns aggregate historical data for the requested security. Returns the latest bar data for the queried stock symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/bars/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/bars/latest/get(getLatestBarForStockSymbol)`.
    public func getLatestBarForStockSymbol(_ input: Operations.getLatestBarForStockSymbol.Input) async throws -> Operations.getLatestBarForStockSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestBarForStockSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/{}/bars/latest",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestBarForStockSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestBarResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Trade data for multiple stock symbols
    ///
    /// The Multi Trades API provides historical trade data for multiple given ticker symbols over a specified time period.
    ///
    /// Returned results are sorted by symbol first then by Trade timestamp. This means that you are likely to see only one symbol in your first response if there are enough Trades for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Trades were found for them.
    ///
    /// - Remark: HTTP `GET /v2/stocks/trades`.
    /// - Remark: Generated from `#/paths//v2/stocks/trades/get(getTradesForMultipleStockSymbols)`.
    public func getTradesForMultipleStockSymbols(_ input: Operations.getTradesForMultipleStockSymbols.Input) async throws -> Operations.getTradesForMultipleStockSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getTradesForMultipleStockSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/trades",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTradesForMultipleStockSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultiTradesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Latest Trades data for multiple stock symbols
    ///
    /// Returns the latest trades data for the queried stock symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/trades/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/trades/latest/get(getLatestTradesForMultipleStockSymbols)`.
    public func getLatestTradesForMultipleStockSymbols(_ input: Operations.getLatestTradesForMultipleStockSymbols.Input) async throws -> Operations.getLatestTradesForMultipleStockSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestTradesForMultipleStockSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/trades/latest",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestTradesForMultipleStockSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestMultiTradesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Trades
    ///
    /// The Trades API provides historical trade data for a given ticker symbol on a specified date. Returns trades for the queried stock signal.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/trades`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/trades/get(getTradesForStockSymbol)`.
    public func getTradesForStockSymbol(_ input: Operations.getTradesForStockSymbol.Input) async throws -> Operations.getTradesForStockSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getTradesForStockSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/{}/trades",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTradesForStockSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TradesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Latest Trade
    ///
    /// The Latest Trade API provides the latest trade data for a given ticker symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/trades/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/trades/latest/get(getLatestTradeForStockSymbol)`.
    public func getLatestTradeForStockSymbol(_ input: Operations.getLatestTradeForStockSymbol.Input) async throws -> Operations.getLatestTradeForStockSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestTradeForStockSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/{}/trades/latest",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestTradeForStockSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestTradeResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Quotes for multiple stock symbols
    ///
    /// The Multi Quotes API provides NBBO quotes for multiple given ticker symbols over a specified time period.
    ///
    /// Returned results are sorted by symbol first then by Quote timestamp. This means that you are likely to see only one symbol in your first response if there are enough Quotes for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Quotes were found for them.
    ///
    /// - Remark: HTTP `GET /v2/stocks/quotes`.
    /// - Remark: Generated from `#/paths//v2/stocks/quotes/get(getQuotesForMultipleStockSymbols)`.
    public func getQuotesForMultipleStockSymbols(_ input: Operations.getQuotesForMultipleStockSymbols.Input) async throws -> Operations.getQuotesForMultipleStockSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getQuotesForMultipleStockSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/quotes",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getQuotesForMultipleStockSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultiQuotesReponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Latest Quotes for multiple stock symbols
    ///
    /// Returns the latest quotes data for the queried stock symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/quotes/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/quotes/latest/get(getLatestQuotesForMultipleStockSymbols)`.
    public func getLatestQuotesForMultipleStockSymbols(_ input: Operations.getLatestQuotesForMultipleStockSymbols.Input) async throws -> Operations.getLatestQuotesForMultipleStockSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestQuotesForMultipleStockSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/quotes/latest",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestQuotesForMultipleStockSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestMultiQuotesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Quotes for stock symbol
    ///
    /// The Quotes API provides NBBO quotes for a single given ticker symbol at a specified date. Returns quotes (NBBOs) for the querried stock symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/quotes`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/quotes/get(getQuotesForStockSymbol)`.
    public func getQuotesForStockSymbol(_ input: Operations.getQuotesForStockSymbol.Input) async throws -> Operations.getQuotesForStockSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getQuotesForStockSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/{}/quotes",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getQuotesForStockSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QuotesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Latest Quote for stock symbol
    ///
    /// The Latest Quote API provides the latest quote data for a given ticker symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/quotes/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/quotes/latest/get(getLatestQuoteForStockSymbol)`.
    public func getLatestQuoteForStockSymbol(_ input: Operations.getLatestQuoteForStockSymbol.Input) async throws -> Operations.getLatestQuoteForStockSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestQuoteForStockSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/{}/quotes/latest",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestQuoteForStockSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestQuoteResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Snapshots for multiple stock symbols
    ///
    /// The Snapshot API for multiple tickers provides the latest trade, latest quote, minute bar daily bar and previous daily bar data for the given ticker symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/snapshots`.
    /// - Remark: Generated from `#/paths//v2/stocks/snapshots/get(getSnapshotsForMultipleStockSymbols)`.
    public func getSnapshotsForMultipleStockSymbols(_ input: Operations.getSnapshotsForMultipleStockSymbols.Input) async throws -> Operations.getSnapshotsForMultipleStockSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSnapshotsForMultipleStockSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/snapshots",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSnapshotsForMultipleStockSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultiSnapshotResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a Snapshot for a stock symbol
    ///
    /// The Snapshot API for one ticker provides the latest trade, latest quote, minute bar daily bar and previous daily bar data for a given ticker symbol. This endpoint returns the snapshot for the requested security.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/snapshot`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/snapshot/get(getSnapshotForStockSymbol)`.
    public func getSnapshotForStockSymbol(_ input: Operations.getSnapshotForStockSymbol.Input) async throws -> Operations.getSnapshotForStockSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSnapshotForStockSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/{}/snapshot",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "feed",
                    value: input.query.feed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSnapshotForStockSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Snapshot.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Trade data for multiple crypto symbols
    ///
    /// The Multi Trades API provides historical trade data for a list of given crypto symbols on a specified date. Returns trades for the queried crypto symbols.
    ///
    /// Returned results are sorted by symbol first then by Trade timestamp. This means that you are likely to see only one symbol in your first response if there are enough Trades for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Trades were found for them.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/trades`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/trades/get(getTradesForMultipleCryptoSymbols)`.
    public func getTradesForMultipleCryptoSymbols(_ input: Operations.getTradesForMultipleCryptoSymbols.Input) async throws -> Operations.getTradesForMultipleCryptoSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getTradesForMultipleCryptoSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/trades",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchanges",
                    value: input.query.exchanges
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTradesForMultipleCryptoSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultiTradesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Latest Trade data for multiple Crypto symbols
    ///
    /// Provides latest trade data for a list of given crypto symbols. 
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/trades/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/trades/latest/get(getLatestTradesForMultipleCryptoSymbols)`.
    public func getLatestTradesForMultipleCryptoSymbols(_ input: Operations.getLatestTradesForMultipleCryptoSymbols.Input) async throws -> Operations.getLatestTradesForMultipleCryptoSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestTradesForMultipleCryptoSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/trades/latest",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchange",
                    value: input.query.exchange
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestTradesForMultipleCryptoSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestMultiTradesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Trade data for a crypto symbol
    ///
    /// The Trades API provides historical trade data for a given crypto symbol on a specified date. Returns trades for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/trades`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/trades/get(getTradesForCryptoSymbol)`.
    public func getTradesForCryptoSymbol(_ input: Operations.getTradesForCryptoSymbol.Input) async throws -> Operations.getTradesForCryptoSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getTradesForCryptoSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/{}/trades",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchanges",
                    value: input.query.exchanges
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTradesForCryptoSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TradesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Latest Trades
    ///
    /// The Latest Trades API provides the latest historical trade data for a given crypto symbol. Returns trades for the queried crypto symbol.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/trades/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/trades/latest/get(getLatestTradesForCryptoSymbol)`.
    public func getLatestTradesForCryptoSymbol(_ input: Operations.getLatestTradesForCryptoSymbol.Input) async throws -> Operations.getLatestTradesForCryptoSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestTradesForCryptoSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/{}/trades/latest",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchange",
                    value: input.query.exchange
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestTradesForCryptoSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestTradeResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Bars for multiple Crypto symbols
    ///
    /// returns aggregate historical data for the requested crypto symbols.
    ///
    /// Returned results are sorted by symbol first then by Bar timestamp. This means that you are likely to see only one symbol in your first response if there are enough Bars for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Bars were found for them.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/bars`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/bars/get(getBarsForMultipleCryptoSymbols)`.
    public func getBarsForMultipleCryptoSymbols(_ input: Operations.getBarsForMultipleCryptoSymbols.Input) async throws -> Operations.getBarsForMultipleCryptoSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getBarsForMultipleCryptoSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/bars",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "timeframe",
                    value: input.query.timeframe
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchanges",
                    value: input.query.exchanges
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBarsForMultipleCryptoSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultiBarsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Latest Bars for multiple Crypto symbols
    ///
    /// returns latest historical data for the requested crypto symbols for a specific exchange
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/bars/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/bars/latest/get(getLatestBarsForMultipleCryptoSymbols)`.
    public func getLatestBarsForMultipleCryptoSymbols(_ input: Operations.getLatestBarsForMultipleCryptoSymbols.Input) async throws -> Operations.getLatestBarsForMultipleCryptoSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestBarsForMultipleCryptoSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/bars/latest",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchange",
                    value: input.query.exchange
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestBarsForMultipleCryptoSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestMultiBarsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Bar data for a crypto symbol
    ///
    /// The Bars API returns aggregate historical data for the requested securities.. Returns bars for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/bars`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/bars/get(getBarsForCryptoSymbol)`.
    public func getBarsForCryptoSymbol(_ input: Operations.getBarsForCryptoSymbol.Input) async throws -> Operations.getBarsForCryptoSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getBarsForCryptoSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/{}/bars",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "timeframe",
                    value: input.query.timeframe
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchanges",
                    value: input.query.exchanges
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBarsForCryptoSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BarsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Latest Bar data for a Crypto symbol
    ///
    /// Gets latest historical bar data for the requested crypto symbol for a specific exchange
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/bars/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/bars/latest/get(getLatestBarsForCryptoSymbol)`.
    public func getLatestBarsForCryptoSymbol(_ input: Operations.getLatestBarsForCryptoSymbol.Input) async throws -> Operations.getLatestBarsForCryptoSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestBarsForCryptoSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/{}/bars/latest",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchange",
                    value: input.query.exchange
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestBarsForCryptoSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestBarResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Quotes for multiple crypto symbols
    ///
    /// The Multi Quotes API provides quotes for a list of given crypto symbols at a specified date. Returns quotes for each of  the queried crypto symbols.
    ///
    /// Returned results are sorted by symbol first then by Quote timestamp. This means that you are likely to see only one symbol in your first response if there are enough Quotes for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Quotes were found for them.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/quotes`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/quotes/get(getQuotesForMultipleCryptoSymbols)`.
    public func getQuotesForMultipleCryptoSymbols(_ input: Operations.getQuotesForMultipleCryptoSymbols.Input) async throws -> Operations.getQuotesForMultipleCryptoSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getQuotesForMultipleCryptoSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/quotes",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchanges",
                    value: input.query.exchanges
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getQuotesForMultipleCryptoSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultiQuotesReponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Latest Quotes for multiple Crypto symbols
    ///
    /// Provides latest quotes for a list of given crypto symbols.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/quotes/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/quotes/latest/get(getLatestQuotesForMultipleCryptoSymbols)`.
    public func getLatestQuotesForMultipleCryptoSymbols(_ input: Operations.getLatestQuotesForMultipleCryptoSymbols.Input) async throws -> Operations.getLatestQuotesForMultipleCryptoSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestQuotesForMultipleCryptoSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/quotes/latest",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchange",
                    value: input.query.exchange
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestQuotesForMultipleCryptoSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestMultiQuotesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Quotes for crypto symbol
    ///
    /// The Quotes API provides quotes for a given crypto symbol at a specified date. Returns quotes for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/quotes`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/quotes/get(getQuotesForCryptoSymbol)`.
    public func getQuotesForCryptoSymbol(_ input: Operations.getQuotesForCryptoSymbol.Input) async throws -> Operations.getQuotesForCryptoSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getQuotesForCryptoSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/{}/quotes",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchanges",
                    value: input.query.exchanges
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getQuotesForCryptoSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QuotesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Latest Quote
    ///
    /// Returns latest quote for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/quotes/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/quotes/latest/get(getLatestQuoteForCryptoSymbol)`.
    public func getLatestQuoteForCryptoSymbol(_ input: Operations.getLatestQuoteForCryptoSymbol.Input) async throws -> Operations.getLatestQuoteForCryptoSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestQuoteForCryptoSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/{}/quotes/latest",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchange",
                    value: input.query.exchange
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestQuoteForCryptoSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestQuoteResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Snapshots for multiple crypto symbols
    ///
    /// The Multi Snapshot API returns the latest trade, latest quote, minute bar daily bar, and previous daily bar data for list of given crypto symbols.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/snapshots`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/snapshots/get(getSnapshotsForMultipleCryptoSymbols)`.
    public func getSnapshotsForMultipleCryptoSymbols(_ input: Operations.getSnapshotsForMultipleCryptoSymbols.Input) async throws -> Operations.getSnapshotsForMultipleCryptoSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSnapshotsForMultipleCryptoSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/snapshots",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchange",
                    value: input.query.exchange
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSnapshotsForMultipleCryptoSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml",
                            "multipart/form-data"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultiSnapshotResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    case "multipart/form-data":
                        body = try converter.getResponseBodyAsMultipart(
                            OpenAPIRuntime.MultipartBody<Operations.getSnapshotsForMultipleCryptoSymbols.Output.Ok.Body.multipartFormPayload>.self,
                            from: responseBody,
                            transforming: { value in
                                .multipartForm(value)
                            },
                            boundary: contentType.requiredBoundary(),
                            allowsUnknownParts: true,
                            requiredExactlyOncePartNames: [],
                            requiredAtLeastOncePartNames: [],
                            atMostOncePartNames: [],
                            zeroOrMoreTimesPartNames: [],
                            decoding: { part in
                                let headerFields = part.headerFields
                                let (name, _) = try converter.extractContentDispositionNameAndFilename(in: headerFields)
                                switch name {
                                default:
                                    return .undocumented(part)
                                }
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a Snapshot for a crypto symbol
    ///
    /// The Snapshot API returns the latest trade, latest quote, minute bar daily bar, and previous daily bar data for a given crypto symbol.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/snapshot`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/snapshot/get(getSnapshotForCryptoSymbol)`.
    public func getSnapshotForCryptoSymbol(_ input: Operations.getSnapshotForCryptoSymbol.Input) async throws -> Operations.getSnapshotForCryptoSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSnapshotForCryptoSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/{}/snapshot",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchange",
                    value: input.query.exchange
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSnapshotForCryptoSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Snapshot.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Latest XBBO for multiple crypto symbols
    ///
    /// Returns the latest XBBO for a given list crypto symbols that calculates the Best Bid and Offer across multiple exchanges. If exchanges is not specified then only the exchanges that can be traded on Alpaca are included in the calculation.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/xbbos/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/xbbos/latest/get(getLatestXBBOForMultipleCryptoSymbols)`.
    public func getLatestXBBOForMultipleCryptoSymbols(_ input: Operations.getLatestXBBOForMultipleCryptoSymbols.Input) async throws -> Operations.getLatestXBBOForMultipleCryptoSymbols.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestXBBOForMultipleCryptoSymbols.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/xbbos/latest",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchanges",
                    value: input.query.exchanges
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestXBBOForMultipleCryptoSymbols.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestMultiXBBOResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Latest XBBO for a single crypto symbol
    ///
    /// Returns the XBBO for a crypto symbol that calculates the Best Bid and Offer across multiple exchanges. If exchanges is not specified then only the exchanges that can be traded on Alpaca are included in the calculation.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/xbbo/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/xbbo/latest/get(getLatestXBBOForCryptoSymbol)`.
    public func getLatestXBBOForCryptoSymbol(_ input: Operations.getLatestXBBOForCryptoSymbol.Input) async throws -> Operations.getLatestXBBOForCryptoSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLatestXBBOForCryptoSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/{}/xbbo/latest",
                    parameters: [
                        input.path.symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exchanges",
                    value: input.query.exchanges
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLatestXBBOForCryptoSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LatestXBBOResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get list of crypto spreads per exchange
    ///
    /// Get list of crypto spreads for the different exchanges Alpaca supports in basis points.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/meta/spreads`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/meta/spreads/get(getCryptoMetaSpreads)`.
    public func getCryptoMetaSpreads(_ input: Operations.getCryptoMetaSpreads.Input) async throws -> Operations.getCryptoMetaSpreads.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getCryptoMetaSpreads.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/crypto/meta/spreads",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getCryptoMetaSpreads.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CryptoSpreadsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// News API
    ///
    /// Returns latest news articles across stocks and crypto. By default returns latest 10 news articles.
    ///
    /// - Remark: HTTP `GET /v1beta1/news`.
    /// - Remark: Generated from `#/paths//v1beta1/news/get(getNews)`.
    public func getNews(_ input: Operations.getNews.Input) async throws -> Operations.getNews.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getNews.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/news",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "include_content",
                    value: input.query.include_content
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exclude_contentless",
                    value: input.query.exclude_contentless
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNews.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetNewsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Top Market Movers by Market type
    ///
    /// Returns top market movers for stocks. By default will return top 5 market gainers and losers.
    ///
    /// - Remark: HTTP `GET /v1beta1/screener/{market_type}/movers`.
    /// - Remark: Generated from `#/paths//v1beta1/screener/{market_type}/movers/get(getTopMoversByMarketType)`.
    public func getTopMoversByMarketType(_ input: Operations.getTopMoversByMarketType.Input) async throws -> Operations.getTopMoversByMarketType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getTopMoversByMarketType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/screener/{}/movers",
                    parameters: [
                        input.path.market_type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "top",
                    value: input.query.top
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTopMoversByMarketType.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MarketMoversResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Logo for symbol
    ///
    /// Returns logo image resource for provided symbol.
    ///
    /// - Remark: HTTP `GET /v1beta1/logos/{crypto_or_stock_symbol}`.
    /// - Remark: Generated from `#/paths//v1beta1/logos/{crypto_or_stock_symbol}/get(getLogoForSymbol)`.
    public func getLogoForSymbol(_ input: Operations.getLogoForSymbol.Input) async throws -> Operations.getLogoForSymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLogoForSymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1beta1/logos/{}",
                    parameters: [
                        input.path.crypto_or_stock_symbol
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "placeholder",
                    value: input.query.placeholder
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLogoForSymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "image/*"
                        ]
                    )
                    switch chosenContentType {
                    case "image/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .image__ast_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get List of supported exchanges
    ///
    /// Returns a json object representing the exchanges we support. The keys are the short form codes you will see in our responses and the values are their respective full names.
    ///
    /// - Remark: HTTP `GET /v2/stocks/meta/exchanges`.
    /// - Remark: Generated from `#/paths//v2/stocks/meta/exchanges/get(getExchanges)`.
    public func getExchanges(_ input: Operations.getExchanges.Input) async throws -> Operations.getExchanges.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getExchanges.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/meta/exchanges",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getExchanges.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ExchangesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get list of Conditions
    ///
    /// Each feed/exchange uses its own set of codes to identify trade and quote conditions, so the same condition may have a different code depending on the originator of the data.
    ///
    /// See [Our documentation](https://alpaca.markets/docs/market-data/#conditions) for more information
    ///
    /// - Remark: HTTP `GET /v2/stocks/meta/conditions/{type}`.
    /// - Remark: Generated from `#/paths//v2/stocks/meta/conditions/{type}/get(getConditions)`.
    public func getConditions(_ input: Operations.getConditions.Input) async throws -> Operations.getConditions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getConditions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/stocks/meta/conditions/{}",
                    parameters: [
                        input.path._type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tape",
                    value: input.query.tape
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getConditions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getConditions.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
