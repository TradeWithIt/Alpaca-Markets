// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
/// A type that performs HTTP operations defined by the OpenAPI document.
public protocol APIProtocol: Sendable {
    /// Get Bar data for multiple stock symbols
    ///
    /// The Multi Bars API returns aggregate historical data for multiple given ticker symbols over a specified time period.
    ///
    /// Returned results are sorted by symbol first then by Bar timestamp. This means that you are likely to see only one symbol in your first response if there are enough Bars for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Bars were found for them.
    ///
    /// - Remark: HTTP `GET /v2/stocks/bars`.
    /// - Remark: Generated from `#/paths//v2/stocks/bars/get(getBarsForMultipleStockSymbols)`.
    func getBarsForMultipleStockSymbols(_ input: Operations.getBarsForMultipleStockSymbols.Input) async throws -> Operations.getBarsForMultipleStockSymbols.Output
    /// Get Latest Bar data for multiple stock symbols
    ///
    /// The Bars API returns aggregate historical data for the requested security. Returns the latest bar data for the queried stock symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/bars/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/bars/latest/get(getLatestBarsForMultipleStockSymbols)`.
    func getLatestBarsForMultipleStockSymbols(_ input: Operations.getLatestBarsForMultipleStockSymbols.Input) async throws -> Operations.getLatestBarsForMultipleStockSymbols.Output
    /// Bars
    ///
    /// The Bars API returns aggregate historical data for the requested security. Returns bars for the queried stock symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/bars`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/bars/get(getBarsForStockSymbol)`.
    func getBarsForStockSymbol(_ input: Operations.getBarsForStockSymbol.Input) async throws -> Operations.getBarsForStockSymbol.Output
    /// Get Latest Bars for Symbol
    ///
    /// The Bars API returns aggregate historical data for the requested security. Returns the latest bar data for the queried stock symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/bars/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/bars/latest/get(getLatestBarForStockSymbol)`.
    func getLatestBarForStockSymbol(_ input: Operations.getLatestBarForStockSymbol.Input) async throws -> Operations.getLatestBarForStockSymbol.Output
    /// Get Trade data for multiple stock symbols
    ///
    /// The Multi Trades API provides historical trade data for multiple given ticker symbols over a specified time period.
    ///
    /// Returned results are sorted by symbol first then by Trade timestamp. This means that you are likely to see only one symbol in your first response if there are enough Trades for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Trades were found for them.
    ///
    /// - Remark: HTTP `GET /v2/stocks/trades`.
    /// - Remark: Generated from `#/paths//v2/stocks/trades/get(getTradesForMultipleStockSymbols)`.
    func getTradesForMultipleStockSymbols(_ input: Operations.getTradesForMultipleStockSymbols.Input) async throws -> Operations.getTradesForMultipleStockSymbols.Output
    /// Get Latest Trades data for multiple stock symbols
    ///
    /// Returns the latest trades data for the queried stock symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/trades/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/trades/latest/get(getLatestTradesForMultipleStockSymbols)`.
    func getLatestTradesForMultipleStockSymbols(_ input: Operations.getLatestTradesForMultipleStockSymbols.Input) async throws -> Operations.getLatestTradesForMultipleStockSymbols.Output
    /// Trades
    ///
    /// The Trades API provides historical trade data for a given ticker symbol on a specified date. Returns trades for the queried stock signal.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/trades`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/trades/get(getTradesForStockSymbol)`.
    func getTradesForStockSymbol(_ input: Operations.getTradesForStockSymbol.Input) async throws -> Operations.getTradesForStockSymbol.Output
    /// Latest Trade
    ///
    /// The Latest Trade API provides the latest trade data for a given ticker symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/trades/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/trades/latest/get(getLatestTradeForStockSymbol)`.
    func getLatestTradeForStockSymbol(_ input: Operations.getLatestTradeForStockSymbol.Input) async throws -> Operations.getLatestTradeForStockSymbol.Output
    /// Get Quotes for multiple stock symbols
    ///
    /// The Multi Quotes API provides NBBO quotes for multiple given ticker symbols over a specified time period.
    ///
    /// Returned results are sorted by symbol first then by Quote timestamp. This means that you are likely to see only one symbol in your first response if there are enough Quotes for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Quotes were found for them.
    ///
    /// - Remark: HTTP `GET /v2/stocks/quotes`.
    /// - Remark: Generated from `#/paths//v2/stocks/quotes/get(getQuotesForMultipleStockSymbols)`.
    func getQuotesForMultipleStockSymbols(_ input: Operations.getQuotesForMultipleStockSymbols.Input) async throws -> Operations.getQuotesForMultipleStockSymbols.Output
    /// Get Latest Quotes for multiple stock symbols
    ///
    /// Returns the latest quotes data for the queried stock symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/quotes/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/quotes/latest/get(getLatestQuotesForMultipleStockSymbols)`.
    func getLatestQuotesForMultipleStockSymbols(_ input: Operations.getLatestQuotesForMultipleStockSymbols.Input) async throws -> Operations.getLatestQuotesForMultipleStockSymbols.Output
    /// Get Quotes for stock symbol
    ///
    /// The Quotes API provides NBBO quotes for a single given ticker symbol at a specified date. Returns quotes (NBBOs) for the querried stock symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/quotes`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/quotes/get(getQuotesForStockSymbol)`.
    func getQuotesForStockSymbol(_ input: Operations.getQuotesForStockSymbol.Input) async throws -> Operations.getQuotesForStockSymbol.Output
    /// Get Latest Quote for stock symbol
    ///
    /// The Latest Quote API provides the latest quote data for a given ticker symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/quotes/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/quotes/latest/get(getLatestQuoteForStockSymbol)`.
    func getLatestQuoteForStockSymbol(_ input: Operations.getLatestQuoteForStockSymbol.Input) async throws -> Operations.getLatestQuoteForStockSymbol.Output
    /// Get Snapshots for multiple stock symbols
    ///
    /// The Snapshot API for multiple tickers provides the latest trade, latest quote, minute bar daily bar and previous daily bar data for the given ticker symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/snapshots`.
    /// - Remark: Generated from `#/paths//v2/stocks/snapshots/get(getSnapshotsForMultipleStockSymbols)`.
    func getSnapshotsForMultipleStockSymbols(_ input: Operations.getSnapshotsForMultipleStockSymbols.Input) async throws -> Operations.getSnapshotsForMultipleStockSymbols.Output
    /// Get a Snapshot for a stock symbol
    ///
    /// The Snapshot API for one ticker provides the latest trade, latest quote, minute bar daily bar and previous daily bar data for a given ticker symbol. This endpoint returns the snapshot for the requested security.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/snapshot`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/snapshot/get(getSnapshotForStockSymbol)`.
    func getSnapshotForStockSymbol(_ input: Operations.getSnapshotForStockSymbol.Input) async throws -> Operations.getSnapshotForStockSymbol.Output
    /// Get Trade data for multiple crypto symbols
    ///
    /// The Multi Trades API provides historical trade data for a list of given crypto symbols on a specified date. Returns trades for the queried crypto symbols.
    ///
    /// Returned results are sorted by symbol first then by Trade timestamp. This means that you are likely to see only one symbol in your first response if there are enough Trades for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Trades were found for them.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/trades`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/trades/get(getTradesForMultipleCryptoSymbols)`.
    func getTradesForMultipleCryptoSymbols(_ input: Operations.getTradesForMultipleCryptoSymbols.Input) async throws -> Operations.getTradesForMultipleCryptoSymbols.Output
    /// Get Latest Trade data for multiple Crypto symbols
    ///
    /// Provides latest trade data for a list of given crypto symbols. 
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/trades/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/trades/latest/get(getLatestTradesForMultipleCryptoSymbols)`.
    func getLatestTradesForMultipleCryptoSymbols(_ input: Operations.getLatestTradesForMultipleCryptoSymbols.Input) async throws -> Operations.getLatestTradesForMultipleCryptoSymbols.Output
    /// Get Trade data for a crypto symbol
    ///
    /// The Trades API provides historical trade data for a given crypto symbol on a specified date. Returns trades for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/trades`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/trades/get(getTradesForCryptoSymbol)`.
    func getTradesForCryptoSymbol(_ input: Operations.getTradesForCryptoSymbol.Input) async throws -> Operations.getTradesForCryptoSymbol.Output
    /// Latest Trades
    ///
    /// The Latest Trades API provides the latest historical trade data for a given crypto symbol. Returns trades for the queried crypto symbol.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/trades/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/trades/latest/get(getLatestTradesForCryptoSymbol)`.
    func getLatestTradesForCryptoSymbol(_ input: Operations.getLatestTradesForCryptoSymbol.Input) async throws -> Operations.getLatestTradesForCryptoSymbol.Output
    /// Get Bars for multiple Crypto symbols
    ///
    /// returns aggregate historical data for the requested crypto symbols.
    ///
    /// Returned results are sorted by symbol first then by Bar timestamp. This means that you are likely to see only one symbol in your first response if there are enough Bars for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Bars were found for them.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/bars`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/bars/get(getBarsForMultipleCryptoSymbols)`.
    func getBarsForMultipleCryptoSymbols(_ input: Operations.getBarsForMultipleCryptoSymbols.Input) async throws -> Operations.getBarsForMultipleCryptoSymbols.Output
    /// Get Latest Bars for multiple Crypto symbols
    ///
    /// returns latest historical data for the requested crypto symbols for a specific exchange
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/bars/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/bars/latest/get(getLatestBarsForMultipleCryptoSymbols)`.
    func getLatestBarsForMultipleCryptoSymbols(_ input: Operations.getLatestBarsForMultipleCryptoSymbols.Input) async throws -> Operations.getLatestBarsForMultipleCryptoSymbols.Output
    /// Get Bar data for a crypto symbol
    ///
    /// The Bars API returns aggregate historical data for the requested securities.. Returns bars for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/bars`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/bars/get(getBarsForCryptoSymbol)`.
    func getBarsForCryptoSymbol(_ input: Operations.getBarsForCryptoSymbol.Input) async throws -> Operations.getBarsForCryptoSymbol.Output
    /// Get Latest Bar data for a Crypto symbol
    ///
    /// Gets latest historical bar data for the requested crypto symbol for a specific exchange
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/bars/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/bars/latest/get(getLatestBarsForCryptoSymbol)`.
    func getLatestBarsForCryptoSymbol(_ input: Operations.getLatestBarsForCryptoSymbol.Input) async throws -> Operations.getLatestBarsForCryptoSymbol.Output
    /// Get Quotes for multiple crypto symbols
    ///
    /// The Multi Quotes API provides quotes for a list of given crypto symbols at a specified date. Returns quotes for each of  the queried crypto symbols.
    ///
    /// Returned results are sorted by symbol first then by Quote timestamp. This means that you are likely to see only one symbol in your first response if there are enough Quotes for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Quotes were found for them.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/quotes`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/quotes/get(getQuotesForMultipleCryptoSymbols)`.
    func getQuotesForMultipleCryptoSymbols(_ input: Operations.getQuotesForMultipleCryptoSymbols.Input) async throws -> Operations.getQuotesForMultipleCryptoSymbols.Output
    /// Get Latest Quotes for multiple Crypto symbols
    ///
    /// Provides latest quotes for a list of given crypto symbols.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/quotes/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/quotes/latest/get(getLatestQuotesForMultipleCryptoSymbols)`.
    func getLatestQuotesForMultipleCryptoSymbols(_ input: Operations.getLatestQuotesForMultipleCryptoSymbols.Input) async throws -> Operations.getLatestQuotesForMultipleCryptoSymbols.Output
    /// Get Quotes for crypto symbol
    ///
    /// The Quotes API provides quotes for a given crypto symbol at a specified date. Returns quotes for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/quotes`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/quotes/get(getQuotesForCryptoSymbol)`.
    func getQuotesForCryptoSymbol(_ input: Operations.getQuotesForCryptoSymbol.Input) async throws -> Operations.getQuotesForCryptoSymbol.Output
    /// Latest Quote
    ///
    /// Returns latest quote for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/quotes/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/quotes/latest/get(getLatestQuoteForCryptoSymbol)`.
    func getLatestQuoteForCryptoSymbol(_ input: Operations.getLatestQuoteForCryptoSymbol.Input) async throws -> Operations.getLatestQuoteForCryptoSymbol.Output
    /// Get Snapshots for multiple crypto symbols
    ///
    /// The Multi Snapshot API returns the latest trade, latest quote, minute bar daily bar, and previous daily bar data for list of given crypto symbols.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/snapshots`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/snapshots/get(getSnapshotsForMultipleCryptoSymbols)`.
    func getSnapshotsForMultipleCryptoSymbols(_ input: Operations.getSnapshotsForMultipleCryptoSymbols.Input) async throws -> Operations.getSnapshotsForMultipleCryptoSymbols.Output
    /// Get a Snapshot for a crypto symbol
    ///
    /// The Snapshot API returns the latest trade, latest quote, minute bar daily bar, and previous daily bar data for a given crypto symbol.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/snapshot`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/snapshot/get(getSnapshotForCryptoSymbol)`.
    func getSnapshotForCryptoSymbol(_ input: Operations.getSnapshotForCryptoSymbol.Input) async throws -> Operations.getSnapshotForCryptoSymbol.Output
    /// Get Latest XBBO for multiple crypto symbols
    ///
    /// Returns the latest XBBO for a given list crypto symbols that calculates the Best Bid and Offer across multiple exchanges. If exchanges is not specified then only the exchanges that can be traded on Alpaca are included in the calculation.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/xbbos/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/xbbos/latest/get(getLatestXBBOForMultipleCryptoSymbols)`.
    func getLatestXBBOForMultipleCryptoSymbols(_ input: Operations.getLatestXBBOForMultipleCryptoSymbols.Input) async throws -> Operations.getLatestXBBOForMultipleCryptoSymbols.Output
    /// Get Latest XBBO for a single crypto symbol
    ///
    /// Returns the XBBO for a crypto symbol that calculates the Best Bid and Offer across multiple exchanges. If exchanges is not specified then only the exchanges that can be traded on Alpaca are included in the calculation.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/xbbo/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/xbbo/latest/get(getLatestXBBOForCryptoSymbol)`.
    func getLatestXBBOForCryptoSymbol(_ input: Operations.getLatestXBBOForCryptoSymbol.Input) async throws -> Operations.getLatestXBBOForCryptoSymbol.Output
    /// Get list of crypto spreads per exchange
    ///
    /// Get list of crypto spreads for the different exchanges Alpaca supports in basis points.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/meta/spreads`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/meta/spreads/get(getCryptoMetaSpreads)`.
    func getCryptoMetaSpreads(_ input: Operations.getCryptoMetaSpreads.Input) async throws -> Operations.getCryptoMetaSpreads.Output
    /// News API
    ///
    /// Returns latest news articles across stocks and crypto. By default returns latest 10 news articles.
    ///
    /// - Remark: HTTP `GET /v1beta1/news`.
    /// - Remark: Generated from `#/paths//v1beta1/news/get(getNews)`.
    func getNews(_ input: Operations.getNews.Input) async throws -> Operations.getNews.Output
    /// Get Top Market Movers by Market type
    ///
    /// Returns top market movers for stocks. By default will return top 5 market gainers and losers.
    ///
    /// - Remark: HTTP `GET /v1beta1/screener/{market_type}/movers`.
    /// - Remark: Generated from `#/paths//v1beta1/screener/{market_type}/movers/get(getTopMoversByMarketType)`.
    func getTopMoversByMarketType(_ input: Operations.getTopMoversByMarketType.Input) async throws -> Operations.getTopMoversByMarketType.Output
    /// Get Logo for symbol
    ///
    /// Returns logo image resource for provided symbol.
    ///
    /// - Remark: HTTP `GET /v1beta1/logos/{crypto_or_stock_symbol}`.
    /// - Remark: Generated from `#/paths//v1beta1/logos/{crypto_or_stock_symbol}/get(getLogoForSymbol)`.
    func getLogoForSymbol(_ input: Operations.getLogoForSymbol.Input) async throws -> Operations.getLogoForSymbol.Output
    /// Get List of supported exchanges
    ///
    /// Returns a json object representing the exchanges we support. The keys are the short form codes you will see in our responses and the values are their respective full names.
    ///
    /// - Remark: HTTP `GET /v2/stocks/meta/exchanges`.
    /// - Remark: Generated from `#/paths//v2/stocks/meta/exchanges/get(getExchanges)`.
    func getExchanges(_ input: Operations.getExchanges.Input) async throws -> Operations.getExchanges.Output
    /// Get list of Conditions
    ///
    /// Each feed/exchange uses its own set of codes to identify trade and quote conditions, so the same condition may have a different code depending on the originator of the data.
    ///
    /// See [Our documentation](https://alpaca.markets/docs/market-data/#conditions) for more information
    ///
    /// - Remark: HTTP `GET /v2/stocks/meta/conditions/{type}`.
    /// - Remark: Generated from `#/paths//v2/stocks/meta/conditions/{type}/get(getConditions)`.
    func getConditions(_ input: Operations.getConditions.Input) async throws -> Operations.getConditions.Output
}

/// Convenience overloads for operation inputs.
extension APIProtocol {
    /// Get Bar data for multiple stock symbols
    ///
    /// The Multi Bars API returns aggregate historical data for multiple given ticker symbols over a specified time period.
    ///
    /// Returned results are sorted by symbol first then by Bar timestamp. This means that you are likely to see only one symbol in your first response if there are enough Bars for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Bars were found for them.
    ///
    /// - Remark: HTTP `GET /v2/stocks/bars`.
    /// - Remark: Generated from `#/paths//v2/stocks/bars/get(getBarsForMultipleStockSymbols)`.
    public func getBarsForMultipleStockSymbols(
        query: Operations.getBarsForMultipleStockSymbols.Input.Query,
        headers: Operations.getBarsForMultipleStockSymbols.Input.Headers = .init()
    ) async throws -> Operations.getBarsForMultipleStockSymbols.Output {
        try await getBarsForMultipleStockSymbols(Operations.getBarsForMultipleStockSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Latest Bar data for multiple stock symbols
    ///
    /// The Bars API returns aggregate historical data for the requested security. Returns the latest bar data for the queried stock symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/bars/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/bars/latest/get(getLatestBarsForMultipleStockSymbols)`.
    public func getLatestBarsForMultipleStockSymbols(
        query: Operations.getLatestBarsForMultipleStockSymbols.Input.Query,
        headers: Operations.getLatestBarsForMultipleStockSymbols.Input.Headers = .init()
    ) async throws -> Operations.getLatestBarsForMultipleStockSymbols.Output {
        try await getLatestBarsForMultipleStockSymbols(Operations.getLatestBarsForMultipleStockSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Bars
    ///
    /// The Bars API returns aggregate historical data for the requested security. Returns bars for the queried stock symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/bars`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/bars/get(getBarsForStockSymbol)`.
    public func getBarsForStockSymbol(
        path: Operations.getBarsForStockSymbol.Input.Path,
        query: Operations.getBarsForStockSymbol.Input.Query,
        headers: Operations.getBarsForStockSymbol.Input.Headers = .init()
    ) async throws -> Operations.getBarsForStockSymbol.Output {
        try await getBarsForStockSymbol(Operations.getBarsForStockSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get Latest Bars for Symbol
    ///
    /// The Bars API returns aggregate historical data for the requested security. Returns the latest bar data for the queried stock symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/bars/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/bars/latest/get(getLatestBarForStockSymbol)`.
    public func getLatestBarForStockSymbol(
        path: Operations.getLatestBarForStockSymbol.Input.Path,
        query: Operations.getLatestBarForStockSymbol.Input.Query = .init(),
        headers: Operations.getLatestBarForStockSymbol.Input.Headers = .init()
    ) async throws -> Operations.getLatestBarForStockSymbol.Output {
        try await getLatestBarForStockSymbol(Operations.getLatestBarForStockSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get Trade data for multiple stock symbols
    ///
    /// The Multi Trades API provides historical trade data for multiple given ticker symbols over a specified time period.
    ///
    /// Returned results are sorted by symbol first then by Trade timestamp. This means that you are likely to see only one symbol in your first response if there are enough Trades for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Trades were found for them.
    ///
    /// - Remark: HTTP `GET /v2/stocks/trades`.
    /// - Remark: Generated from `#/paths//v2/stocks/trades/get(getTradesForMultipleStockSymbols)`.
    public func getTradesForMultipleStockSymbols(
        query: Operations.getTradesForMultipleStockSymbols.Input.Query,
        headers: Operations.getTradesForMultipleStockSymbols.Input.Headers = .init()
    ) async throws -> Operations.getTradesForMultipleStockSymbols.Output {
        try await getTradesForMultipleStockSymbols(Operations.getTradesForMultipleStockSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Latest Trades data for multiple stock symbols
    ///
    /// Returns the latest trades data for the queried stock symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/trades/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/trades/latest/get(getLatestTradesForMultipleStockSymbols)`.
    public func getLatestTradesForMultipleStockSymbols(
        query: Operations.getLatestTradesForMultipleStockSymbols.Input.Query,
        headers: Operations.getLatestTradesForMultipleStockSymbols.Input.Headers = .init()
    ) async throws -> Operations.getLatestTradesForMultipleStockSymbols.Output {
        try await getLatestTradesForMultipleStockSymbols(Operations.getLatestTradesForMultipleStockSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Trades
    ///
    /// The Trades API provides historical trade data for a given ticker symbol on a specified date. Returns trades for the queried stock signal.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/trades`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/trades/get(getTradesForStockSymbol)`.
    public func getTradesForStockSymbol(
        path: Operations.getTradesForStockSymbol.Input.Path,
        query: Operations.getTradesForStockSymbol.Input.Query = .init(),
        headers: Operations.getTradesForStockSymbol.Input.Headers = .init()
    ) async throws -> Operations.getTradesForStockSymbol.Output {
        try await getTradesForStockSymbol(Operations.getTradesForStockSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Latest Trade
    ///
    /// The Latest Trade API provides the latest trade data for a given ticker symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/trades/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/trades/latest/get(getLatestTradeForStockSymbol)`.
    public func getLatestTradeForStockSymbol(
        path: Operations.getLatestTradeForStockSymbol.Input.Path,
        query: Operations.getLatestTradeForStockSymbol.Input.Query = .init(),
        headers: Operations.getLatestTradeForStockSymbol.Input.Headers = .init()
    ) async throws -> Operations.getLatestTradeForStockSymbol.Output {
        try await getLatestTradeForStockSymbol(Operations.getLatestTradeForStockSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get Quotes for multiple stock symbols
    ///
    /// The Multi Quotes API provides NBBO quotes for multiple given ticker symbols over a specified time period.
    ///
    /// Returned results are sorted by symbol first then by Quote timestamp. This means that you are likely to see only one symbol in your first response if there are enough Quotes for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Quotes were found for them.
    ///
    /// - Remark: HTTP `GET /v2/stocks/quotes`.
    /// - Remark: Generated from `#/paths//v2/stocks/quotes/get(getQuotesForMultipleStockSymbols)`.
    public func getQuotesForMultipleStockSymbols(
        query: Operations.getQuotesForMultipleStockSymbols.Input.Query,
        headers: Operations.getQuotesForMultipleStockSymbols.Input.Headers = .init()
    ) async throws -> Operations.getQuotesForMultipleStockSymbols.Output {
        try await getQuotesForMultipleStockSymbols(Operations.getQuotesForMultipleStockSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Latest Quotes for multiple stock symbols
    ///
    /// Returns the latest quotes data for the queried stock symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/quotes/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/quotes/latest/get(getLatestQuotesForMultipleStockSymbols)`.
    public func getLatestQuotesForMultipleStockSymbols(
        query: Operations.getLatestQuotesForMultipleStockSymbols.Input.Query,
        headers: Operations.getLatestQuotesForMultipleStockSymbols.Input.Headers = .init()
    ) async throws -> Operations.getLatestQuotesForMultipleStockSymbols.Output {
        try await getLatestQuotesForMultipleStockSymbols(Operations.getLatestQuotesForMultipleStockSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Quotes for stock symbol
    ///
    /// The Quotes API provides NBBO quotes for a single given ticker symbol at a specified date. Returns quotes (NBBOs) for the querried stock symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/quotes`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/quotes/get(getQuotesForStockSymbol)`.
    public func getQuotesForStockSymbol(
        path: Operations.getQuotesForStockSymbol.Input.Path,
        query: Operations.getQuotesForStockSymbol.Input.Query = .init(),
        headers: Operations.getQuotesForStockSymbol.Input.Headers = .init()
    ) async throws -> Operations.getQuotesForStockSymbol.Output {
        try await getQuotesForStockSymbol(Operations.getQuotesForStockSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get Latest Quote for stock symbol
    ///
    /// The Latest Quote API provides the latest quote data for a given ticker symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/quotes/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/quotes/latest/get(getLatestQuoteForStockSymbol)`.
    public func getLatestQuoteForStockSymbol(
        path: Operations.getLatestQuoteForStockSymbol.Input.Path,
        query: Operations.getLatestQuoteForStockSymbol.Input.Query = .init(),
        headers: Operations.getLatestQuoteForStockSymbol.Input.Headers = .init()
    ) async throws -> Operations.getLatestQuoteForStockSymbol.Output {
        try await getLatestQuoteForStockSymbol(Operations.getLatestQuoteForStockSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get Snapshots for multiple stock symbols
    ///
    /// The Snapshot API for multiple tickers provides the latest trade, latest quote, minute bar daily bar and previous daily bar data for the given ticker symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/snapshots`.
    /// - Remark: Generated from `#/paths//v2/stocks/snapshots/get(getSnapshotsForMultipleStockSymbols)`.
    public func getSnapshotsForMultipleStockSymbols(
        query: Operations.getSnapshotsForMultipleStockSymbols.Input.Query,
        headers: Operations.getSnapshotsForMultipleStockSymbols.Input.Headers = .init()
    ) async throws -> Operations.getSnapshotsForMultipleStockSymbols.Output {
        try await getSnapshotsForMultipleStockSymbols(Operations.getSnapshotsForMultipleStockSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get a Snapshot for a stock symbol
    ///
    /// The Snapshot API for one ticker provides the latest trade, latest quote, minute bar daily bar and previous daily bar data for a given ticker symbol. This endpoint returns the snapshot for the requested security.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/snapshot`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/snapshot/get(getSnapshotForStockSymbol)`.
    public func getSnapshotForStockSymbol(
        path: Operations.getSnapshotForStockSymbol.Input.Path,
        query: Operations.getSnapshotForStockSymbol.Input.Query = .init(),
        headers: Operations.getSnapshotForStockSymbol.Input.Headers = .init()
    ) async throws -> Operations.getSnapshotForStockSymbol.Output {
        try await getSnapshotForStockSymbol(Operations.getSnapshotForStockSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get Trade data for multiple crypto symbols
    ///
    /// The Multi Trades API provides historical trade data for a list of given crypto symbols on a specified date. Returns trades for the queried crypto symbols.
    ///
    /// Returned results are sorted by symbol first then by Trade timestamp. This means that you are likely to see only one symbol in your first response if there are enough Trades for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Trades were found for them.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/trades`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/trades/get(getTradesForMultipleCryptoSymbols)`.
    public func getTradesForMultipleCryptoSymbols(
        query: Operations.getTradesForMultipleCryptoSymbols.Input.Query,
        headers: Operations.getTradesForMultipleCryptoSymbols.Input.Headers = .init()
    ) async throws -> Operations.getTradesForMultipleCryptoSymbols.Output {
        try await getTradesForMultipleCryptoSymbols(Operations.getTradesForMultipleCryptoSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Latest Trade data for multiple Crypto symbols
    ///
    /// Provides latest trade data for a list of given crypto symbols. 
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/trades/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/trades/latest/get(getLatestTradesForMultipleCryptoSymbols)`.
    public func getLatestTradesForMultipleCryptoSymbols(
        query: Operations.getLatestTradesForMultipleCryptoSymbols.Input.Query,
        headers: Operations.getLatestTradesForMultipleCryptoSymbols.Input.Headers = .init()
    ) async throws -> Operations.getLatestTradesForMultipleCryptoSymbols.Output {
        try await getLatestTradesForMultipleCryptoSymbols(Operations.getLatestTradesForMultipleCryptoSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Trade data for a crypto symbol
    ///
    /// The Trades API provides historical trade data for a given crypto symbol on a specified date. Returns trades for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/trades`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/trades/get(getTradesForCryptoSymbol)`.
    public func getTradesForCryptoSymbol(
        path: Operations.getTradesForCryptoSymbol.Input.Path,
        query: Operations.getTradesForCryptoSymbol.Input.Query = .init(),
        headers: Operations.getTradesForCryptoSymbol.Input.Headers = .init()
    ) async throws -> Operations.getTradesForCryptoSymbol.Output {
        try await getTradesForCryptoSymbol(Operations.getTradesForCryptoSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Latest Trades
    ///
    /// The Latest Trades API provides the latest historical trade data for a given crypto symbol. Returns trades for the queried crypto symbol.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/trades/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/trades/latest/get(getLatestTradesForCryptoSymbol)`.
    public func getLatestTradesForCryptoSymbol(
        path: Operations.getLatestTradesForCryptoSymbol.Input.Path,
        query: Operations.getLatestTradesForCryptoSymbol.Input.Query,
        headers: Operations.getLatestTradesForCryptoSymbol.Input.Headers = .init()
    ) async throws -> Operations.getLatestTradesForCryptoSymbol.Output {
        try await getLatestTradesForCryptoSymbol(Operations.getLatestTradesForCryptoSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get Bars for multiple Crypto symbols
    ///
    /// returns aggregate historical data for the requested crypto symbols.
    ///
    /// Returned results are sorted by symbol first then by Bar timestamp. This means that you are likely to see only one symbol in your first response if there are enough Bars for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Bars were found for them.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/bars`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/bars/get(getBarsForMultipleCryptoSymbols)`.
    public func getBarsForMultipleCryptoSymbols(
        query: Operations.getBarsForMultipleCryptoSymbols.Input.Query,
        headers: Operations.getBarsForMultipleCryptoSymbols.Input.Headers = .init()
    ) async throws -> Operations.getBarsForMultipleCryptoSymbols.Output {
        try await getBarsForMultipleCryptoSymbols(Operations.getBarsForMultipleCryptoSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Latest Bars for multiple Crypto symbols
    ///
    /// returns latest historical data for the requested crypto symbols for a specific exchange
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/bars/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/bars/latest/get(getLatestBarsForMultipleCryptoSymbols)`.
    public func getLatestBarsForMultipleCryptoSymbols(
        query: Operations.getLatestBarsForMultipleCryptoSymbols.Input.Query,
        headers: Operations.getLatestBarsForMultipleCryptoSymbols.Input.Headers = .init()
    ) async throws -> Operations.getLatestBarsForMultipleCryptoSymbols.Output {
        try await getLatestBarsForMultipleCryptoSymbols(Operations.getLatestBarsForMultipleCryptoSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Bar data for a crypto symbol
    ///
    /// The Bars API returns aggregate historical data for the requested securities.. Returns bars for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/bars`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/bars/get(getBarsForCryptoSymbol)`.
    public func getBarsForCryptoSymbol(
        path: Operations.getBarsForCryptoSymbol.Input.Path,
        query: Operations.getBarsForCryptoSymbol.Input.Query,
        headers: Operations.getBarsForCryptoSymbol.Input.Headers = .init()
    ) async throws -> Operations.getBarsForCryptoSymbol.Output {
        try await getBarsForCryptoSymbol(Operations.getBarsForCryptoSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get Latest Bar data for a Crypto symbol
    ///
    /// Gets latest historical bar data for the requested crypto symbol for a specific exchange
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/bars/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/bars/latest/get(getLatestBarsForCryptoSymbol)`.
    public func getLatestBarsForCryptoSymbol(
        path: Operations.getLatestBarsForCryptoSymbol.Input.Path,
        query: Operations.getLatestBarsForCryptoSymbol.Input.Query,
        headers: Operations.getLatestBarsForCryptoSymbol.Input.Headers = .init()
    ) async throws -> Operations.getLatestBarsForCryptoSymbol.Output {
        try await getLatestBarsForCryptoSymbol(Operations.getLatestBarsForCryptoSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get Quotes for multiple crypto symbols
    ///
    /// The Multi Quotes API provides quotes for a list of given crypto symbols at a specified date. Returns quotes for each of  the queried crypto symbols.
    ///
    /// Returned results are sorted by symbol first then by Quote timestamp. This means that you are likely to see only one symbol in your first response if there are enough Quotes for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Quotes were found for them.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/quotes`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/quotes/get(getQuotesForMultipleCryptoSymbols)`.
    public func getQuotesForMultipleCryptoSymbols(
        query: Operations.getQuotesForMultipleCryptoSymbols.Input.Query,
        headers: Operations.getQuotesForMultipleCryptoSymbols.Input.Headers = .init()
    ) async throws -> Operations.getQuotesForMultipleCryptoSymbols.Output {
        try await getQuotesForMultipleCryptoSymbols(Operations.getQuotesForMultipleCryptoSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Latest Quotes for multiple Crypto symbols
    ///
    /// Provides latest quotes for a list of given crypto symbols.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/quotes/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/quotes/latest/get(getLatestQuotesForMultipleCryptoSymbols)`.
    public func getLatestQuotesForMultipleCryptoSymbols(
        query: Operations.getLatestQuotesForMultipleCryptoSymbols.Input.Query,
        headers: Operations.getLatestQuotesForMultipleCryptoSymbols.Input.Headers = .init()
    ) async throws -> Operations.getLatestQuotesForMultipleCryptoSymbols.Output {
        try await getLatestQuotesForMultipleCryptoSymbols(Operations.getLatestQuotesForMultipleCryptoSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Quotes for crypto symbol
    ///
    /// The Quotes API provides quotes for a given crypto symbol at a specified date. Returns quotes for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/quotes`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/quotes/get(getQuotesForCryptoSymbol)`.
    public func getQuotesForCryptoSymbol(
        path: Operations.getQuotesForCryptoSymbol.Input.Path,
        query: Operations.getQuotesForCryptoSymbol.Input.Query = .init(),
        headers: Operations.getQuotesForCryptoSymbol.Input.Headers = .init()
    ) async throws -> Operations.getQuotesForCryptoSymbol.Output {
        try await getQuotesForCryptoSymbol(Operations.getQuotesForCryptoSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Latest Quote
    ///
    /// Returns latest quote for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/quotes/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/quotes/latest/get(getLatestQuoteForCryptoSymbol)`.
    public func getLatestQuoteForCryptoSymbol(
        path: Operations.getLatestQuoteForCryptoSymbol.Input.Path,
        query: Operations.getLatestQuoteForCryptoSymbol.Input.Query,
        headers: Operations.getLatestQuoteForCryptoSymbol.Input.Headers = .init()
    ) async throws -> Operations.getLatestQuoteForCryptoSymbol.Output {
        try await getLatestQuoteForCryptoSymbol(Operations.getLatestQuoteForCryptoSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get Snapshots for multiple crypto symbols
    ///
    /// The Multi Snapshot API returns the latest trade, latest quote, minute bar daily bar, and previous daily bar data for list of given crypto symbols.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/snapshots`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/snapshots/get(getSnapshotsForMultipleCryptoSymbols)`.
    public func getSnapshotsForMultipleCryptoSymbols(
        query: Operations.getSnapshotsForMultipleCryptoSymbols.Input.Query,
        headers: Operations.getSnapshotsForMultipleCryptoSymbols.Input.Headers = .init()
    ) async throws -> Operations.getSnapshotsForMultipleCryptoSymbols.Output {
        try await getSnapshotsForMultipleCryptoSymbols(Operations.getSnapshotsForMultipleCryptoSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get a Snapshot for a crypto symbol
    ///
    /// The Snapshot API returns the latest trade, latest quote, minute bar daily bar, and previous daily bar data for a given crypto symbol.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/snapshot`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/snapshot/get(getSnapshotForCryptoSymbol)`.
    public func getSnapshotForCryptoSymbol(
        path: Operations.getSnapshotForCryptoSymbol.Input.Path,
        query: Operations.getSnapshotForCryptoSymbol.Input.Query,
        headers: Operations.getSnapshotForCryptoSymbol.Input.Headers = .init()
    ) async throws -> Operations.getSnapshotForCryptoSymbol.Output {
        try await getSnapshotForCryptoSymbol(Operations.getSnapshotForCryptoSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get Latest XBBO for multiple crypto symbols
    ///
    /// Returns the latest XBBO for a given list crypto symbols that calculates the Best Bid and Offer across multiple exchanges. If exchanges is not specified then only the exchanges that can be traded on Alpaca are included in the calculation.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/xbbos/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/xbbos/latest/get(getLatestXBBOForMultipleCryptoSymbols)`.
    public func getLatestXBBOForMultipleCryptoSymbols(
        query: Operations.getLatestXBBOForMultipleCryptoSymbols.Input.Query,
        headers: Operations.getLatestXBBOForMultipleCryptoSymbols.Input.Headers = .init()
    ) async throws -> Operations.getLatestXBBOForMultipleCryptoSymbols.Output {
        try await getLatestXBBOForMultipleCryptoSymbols(Operations.getLatestXBBOForMultipleCryptoSymbols.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Latest XBBO for a single crypto symbol
    ///
    /// Returns the XBBO for a crypto symbol that calculates the Best Bid and Offer across multiple exchanges. If exchanges is not specified then only the exchanges that can be traded on Alpaca are included in the calculation.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/xbbo/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/xbbo/latest/get(getLatestXBBOForCryptoSymbol)`.
    public func getLatestXBBOForCryptoSymbol(
        path: Operations.getLatestXBBOForCryptoSymbol.Input.Path,
        query: Operations.getLatestXBBOForCryptoSymbol.Input.Query = .init(),
        headers: Operations.getLatestXBBOForCryptoSymbol.Input.Headers = .init()
    ) async throws -> Operations.getLatestXBBOForCryptoSymbol.Output {
        try await getLatestXBBOForCryptoSymbol(Operations.getLatestXBBOForCryptoSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get list of crypto spreads per exchange
    ///
    /// Get list of crypto spreads for the different exchanges Alpaca supports in basis points.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/meta/spreads`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/meta/spreads/get(getCryptoMetaSpreads)`.
    public func getCryptoMetaSpreads(headers: Operations.getCryptoMetaSpreads.Input.Headers = .init()) async throws -> Operations.getCryptoMetaSpreads.Output {
        try await getCryptoMetaSpreads(Operations.getCryptoMetaSpreads.Input(headers: headers))
    }
    /// News API
    ///
    /// Returns latest news articles across stocks and crypto. By default returns latest 10 news articles.
    ///
    /// - Remark: HTTP `GET /v1beta1/news`.
    /// - Remark: Generated from `#/paths//v1beta1/news/get(getNews)`.
    public func getNews(
        query: Operations.getNews.Input.Query,
        headers: Operations.getNews.Input.Headers = .init()
    ) async throws -> Operations.getNews.Output {
        try await getNews(Operations.getNews.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Top Market Movers by Market type
    ///
    /// Returns top market movers for stocks. By default will return top 5 market gainers and losers.
    ///
    /// - Remark: HTTP `GET /v1beta1/screener/{market_type}/movers`.
    /// - Remark: Generated from `#/paths//v1beta1/screener/{market_type}/movers/get(getTopMoversByMarketType)`.
    public func getTopMoversByMarketType(
        path: Operations.getTopMoversByMarketType.Input.Path,
        query: Operations.getTopMoversByMarketType.Input.Query = .init(),
        headers: Operations.getTopMoversByMarketType.Input.Headers = .init()
    ) async throws -> Operations.getTopMoversByMarketType.Output {
        try await getTopMoversByMarketType(Operations.getTopMoversByMarketType.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get Logo for symbol
    ///
    /// Returns logo image resource for provided symbol.
    ///
    /// - Remark: HTTP `GET /v1beta1/logos/{crypto_or_stock_symbol}`.
    /// - Remark: Generated from `#/paths//v1beta1/logos/{crypto_or_stock_symbol}/get(getLogoForSymbol)`.
    public func getLogoForSymbol(
        path: Operations.getLogoForSymbol.Input.Path,
        query: Operations.getLogoForSymbol.Input.Query = .init(),
        headers: Operations.getLogoForSymbol.Input.Headers = .init()
    ) async throws -> Operations.getLogoForSymbol.Output {
        try await getLogoForSymbol(Operations.getLogoForSymbol.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get List of supported exchanges
    ///
    /// Returns a json object representing the exchanges we support. The keys are the short form codes you will see in our responses and the values are their respective full names.
    ///
    /// - Remark: HTTP `GET /v2/stocks/meta/exchanges`.
    /// - Remark: Generated from `#/paths//v2/stocks/meta/exchanges/get(getExchanges)`.
    public func getExchanges(headers: Operations.getExchanges.Input.Headers = .init()) async throws -> Operations.getExchanges.Output {
        try await getExchanges(Operations.getExchanges.Input(headers: headers))
    }
    /// Get list of Conditions
    ///
    /// Each feed/exchange uses its own set of codes to identify trade and quote conditions, so the same condition may have a different code depending on the originator of the data.
    ///
    /// See [Our documentation](https://alpaca.markets/docs/market-data/#conditions) for more information
    ///
    /// - Remark: HTTP `GET /v2/stocks/meta/conditions/{type}`.
    /// - Remark: Generated from `#/paths//v2/stocks/meta/conditions/{type}/get(getConditions)`.
    public func getConditions(
        path: Operations.getConditions.Input.Path,
        query: Operations.getConditions.Input.Query,
        headers: Operations.getConditions.Input.Headers = .init()
    ) async throws -> Operations.getConditions.Output {
        try await getConditions(Operations.getConditions.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
}

/// Server URLs defined in the OpenAPI document.
public enum Servers {
    /// Production
    public static func server1() throws -> Foundation.URL {
        try Foundation.URL(
            validatingOpenAPIServerURL: "https://data.alpaca.markets",
            variables: []
        )
    }
    /// Sandbox
    public static func server2() throws -> Foundation.URL {
        try Foundation.URL(
            validatingOpenAPIServerURL: "https://data.sandbox.alpaca.markets",
            variables: []
        )
    }
}

/// Types generated from the components section of the OpenAPI document.
public enum Components {
    /// Types generated from the `#/components/schemas` section of the OpenAPI document.
    public enum Schemas {
        /// A model representing a trade
        ///
        /// - Remark: Generated from `#/components/schemas/Trade`.
        public struct Trade: Codable, Hashable, Sendable {
            /// Timestamp in RFC-3339 format with nanosecond precision
            ///
            /// - Remark: Generated from `#/components/schemas/Trade/t`.
            public var t: Foundation.Date?
            /// Exchange where the trade happened.
            ///
            /// - Remark: Generated from `#/components/schemas/Trade/x`.
            public var x: Swift.String
            /// Trade price.
            ///
            /// - Remark: Generated from `#/components/schemas/Trade/p`.
            public var p: Swift.Double?
            /// Trade Size.
            ///
            /// - Remark: Generated from `#/components/schemas/Trade/s`.
            public var s: Swift.Double?
            /// Trade conditions (Stock trade only)
            ///
            /// - Remark: Generated from `#/components/schemas/Trade/c`.
            public var c: [Swift.String]?
            /// Trade ID
            ///
            /// - Remark: Generated from `#/components/schemas/Trade/i`.
            public var i: Swift.Int64
            /// Tape (Stock trade only)
            ///
            /// - Remark: Generated from `#/components/schemas/Trade/z`.
            public var z: Swift.String?
            /// Taker's side (crypto trade only)
            ///
            /// - Remark: Generated from `#/components/schemas/Trade/tks`.
            public var tks: Swift.String?
            /// Creates a new `Trade`.
            ///
            /// - Parameters:
            ///   - t: Timestamp in RFC-3339 format with nanosecond precision
            ///   - x: Exchange where the trade happened.
            ///   - p: Trade price.
            ///   - s: Trade Size.
            ///   - c: Trade conditions (Stock trade only)
            ///   - i: Trade ID
            ///   - z: Tape (Stock trade only)
            ///   - tks: Taker's side (crypto trade only)
            public init(
                t: Foundation.Date? = nil,
                x: Swift.String,
                p: Swift.Double? = nil,
                s: Swift.Double? = nil,
                c: [Swift.String]? = nil,
                i: Swift.Int64,
                z: Swift.String? = nil,
                tks: Swift.String? = nil
            ) {
                self.t = t
                self.x = x
                self.p = p
                self.s = s
                self.c = c
                self.i = i
                self.z = z
                self.tks = tks
            }
            public enum CodingKeys: String, CodingKey {
                case t
                case x
                case p
                case s
                case c
                case i
                case z
                case tks
            }
        }
        /// A model representing the result of hitting the Trades api.
        ///
        /// Represents multiple Trades for a single symbol with support for paging.
        ///
        /// - Remark: Generated from `#/components/schemas/TradesResponse`.
        public struct TradesResponse: Codable, Hashable, Sendable {
            /// Array of trades
            ///
            /// - Remark: Generated from `#/components/schemas/TradesResponse/trades`.
            public var trades: [Components.Schemas.Trade]
            /// Symbol that was queried
            ///
            /// - Remark: Generated from `#/components/schemas/TradesResponse/symbol`.
            public var symbol: Swift.String
            /// Token that can be used to query the next page
            ///
            /// - Remark: Generated from `#/components/schemas/TradesResponse/next_page_token`.
            public var next_page_token: Swift.String?
            /// Creates a new `TradesResponse`.
            ///
            /// - Parameters:
            ///   - trades: Array of trades
            ///   - symbol: Symbol that was queried
            ///   - next_page_token: Token that can be used to query the next page
            public init(
                trades: [Components.Schemas.Trade],
                symbol: Swift.String,
                next_page_token: Swift.String? = nil
            ) {
                self.trades = trades
                self.symbol = symbol
                self.next_page_token = next_page_token
            }
            public enum CodingKeys: String, CodingKey {
                case trades
                case symbol
                case next_page_token
            }
        }
        /// A model representing the result of hitting the Latest Trade api.
        ///
        /// Represents a single Trade that should be the latest trade data for a given ticker symbol
        ///
        /// - Remark: Generated from `#/components/schemas/LatestTradeResponse`.
        public struct LatestTradeResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LatestTradeResponse/trade`.
            public var trade: Components.Schemas.Trade?
            /// Symbol that was queried
            ///
            /// - Remark: Generated from `#/components/schemas/LatestTradeResponse/symbol`.
            public var symbol: Swift.String
            /// Creates a new `LatestTradeResponse`.
            ///
            /// - Parameters:
            ///   - trade:
            ///   - symbol: Symbol that was queried
            public init(
                trade: Components.Schemas.Trade? = nil,
                symbol: Swift.String
            ) {
                self.trade = trade
                self.symbol = symbol
            }
            public enum CodingKeys: String, CodingKey {
                case trade
                case symbol
            }
        }
        /// A model representing the result of hitting the Multi Trades api; represents multiple trades for multiple symbols.
        ///
        /// Returned results are sorted by symbol first then by Trade timestamp. This means that you are likely to see only one symbol in your first response if there are enough Trades for that symbol to hit the limit you requested on that request.
        ///
        /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Trades were found for them.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/MultiTradesResponse`.
        public struct MultiTradesResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/MultiTradesResponse/trades`.
            public struct tradesPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: [Components.Schemas.Trade]]
                /// Creates a new `tradesPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: [Components.Schemas.Trade]] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// - Remark: Generated from `#/components/schemas/MultiTradesResponse/trades`.
            public var trades: Components.Schemas.MultiTradesResponse.tradesPayload
            /// - Remark: Generated from `#/components/schemas/MultiTradesResponse/next_page_token`.
            public var next_page_token: Swift.String?
            /// Creates a new `MultiTradesResponse`.
            ///
            /// - Parameters:
            ///   - trades:
            ///   - next_page_token:
            public init(
                trades: Components.Schemas.MultiTradesResponse.tradesPayload,
                next_page_token: Swift.String? = nil
            ) {
                self.trades = trades
                self.next_page_token = next_page_token
            }
            public enum CodingKeys: String, CodingKey {
                case trades
                case next_page_token
            }
        }
        /// - Remark: Generated from `#/components/schemas/LatestMultiTradesResponse`.
        public struct LatestMultiTradesResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LatestMultiTradesResponse/trades`.
            public struct tradesPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Components.Schemas.Trade]
                /// Creates a new `tradesPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Components.Schemas.Trade] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// - Remark: Generated from `#/components/schemas/LatestMultiTradesResponse/trades`.
            public var trades: Components.Schemas.LatestMultiTradesResponse.tradesPayload
            /// Creates a new `LatestMultiTradesResponse`.
            ///
            /// - Parameters:
            ///   - trades:
            public init(trades: Components.Schemas.LatestMultiTradesResponse.tradesPayload) {
                self.trades = trades
            }
            public enum CodingKeys: String, CodingKey {
                case trades
            }
        }
        /// The Snapshot API for one ticker provides the latest trade, latest quote, minute bar daily bar and previous daily bar data for a given ticker symbol.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/Snapshot`.
        public struct Snapshot: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/Snapshot/latestTrade`.
            public var latestTrade: Components.Schemas.Trade?
            /// - Remark: Generated from `#/components/schemas/Snapshot/latestQuote`.
            public var latestQuote: Components.Schemas.Quote?
            /// - Remark: Generated from `#/components/schemas/Snapshot/minuteBar`.
            public var minuteBar: Components.Schemas.Bar?
            /// - Remark: Generated from `#/components/schemas/Snapshot/dailyBar`.
            public var dailyBar: Components.Schemas.Bar?
            /// - Remark: Generated from `#/components/schemas/Snapshot/prevDailyBar`.
            public var prevDailyBar: Components.Schemas.Bar?
            /// Creates a new `Snapshot`.
            ///
            /// - Parameters:
            ///   - latestTrade:
            ///   - latestQuote:
            ///   - minuteBar:
            ///   - dailyBar:
            ///   - prevDailyBar:
            public init(
                latestTrade: Components.Schemas.Trade? = nil,
                latestQuote: Components.Schemas.Quote? = nil,
                minuteBar: Components.Schemas.Bar? = nil,
                dailyBar: Components.Schemas.Bar? = nil,
                prevDailyBar: Components.Schemas.Bar? = nil
            ) {
                self.latestTrade = latestTrade
                self.latestQuote = latestQuote
                self.minuteBar = minuteBar
                self.dailyBar = dailyBar
                self.prevDailyBar = prevDailyBar
            }
            public enum CodingKeys: String, CodingKey {
                case latestTrade
                case latestQuote
                case minuteBar
                case dailyBar
                case prevDailyBar
            }
        }
        /// A model representing the result of hitting the Multi Snapshots api; represents Snapshots for multiple symbols.
        ///
        /// The result is an object whose keys are the requested symbols and values are their respecitve Snapshot
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/MultiSnapshotResponse`.
        public struct MultiSnapshotResponse: Codable, Hashable, Sendable {
            /// A container of undocumented properties.
            public var additionalProperties: [String: Components.Schemas.Snapshot]
            /// Creates a new `MultiSnapshotResponse`.
            ///
            /// - Parameters:
            ///   - additionalProperties: A container of undocumented properties.
            public init(additionalProperties: [String: Components.Schemas.Snapshot] = .init()) {
                self.additionalProperties = additionalProperties
            }
            public init(from decoder: any Decoder) throws {
                additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
            }
            public func encode(to encoder: any Encoder) throws {
                try encoder.encodeAdditionalProperties(additionalProperties)
            }
        }
        /// The Quotes API provides NBBO quotes for a given ticker symbol at a specified date.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/Quote`.
        public struct Quote: Codable, Hashable, Sendable {
            /// Timestamp in RFC-3339 format with nanosecond precision
            ///
            /// - Remark: Generated from `#/components/schemas/Quote/t`.
            public var t: Foundation.Date
            /// ask exchange (Stock quote only)
            ///
            /// - Remark: Generated from `#/components/schemas/Quote/ax`.
            public var ax: Swift.String?
            /// ask price
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Quote/ap`.
            public var ap: Swift.Double?
            /// ask size
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Quote/as`.
            public var _as: Swift.Double?
            /// bid exchange (Stock quote only)
            ///
            /// - Remark: Generated from `#/components/schemas/Quote/bx`.
            public var bx: Swift.String?
            /// bid price
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Quote/bp`.
            public var bp: Swift.Double?
            /// bid size
            ///
            /// - Remark: Generated from `#/components/schemas/Quote/bs`.
            public var bs: Swift.Double?
            /// quote conditions (Stock quotes only)
            ///
            /// - Remark: Generated from `#/components/schemas/Quote/c`.
            public var c: [Swift.String]?
            /// Exchange (Crypto quote Only)
            ///
            /// - Remark: Generated from `#/components/schemas/Quote/x`.
            public var x: Swift.String?
            /// Tape (Stock quote only)
            ///
            /// - Remark: Generated from `#/components/schemas/Quote/z`.
            public var z: Swift.String?
            /// Creates a new `Quote`.
            ///
            /// - Parameters:
            ///   - t: Timestamp in RFC-3339 format with nanosecond precision
            ///   - ax: ask exchange (Stock quote only)
            ///   - ap: ask price
            ///   - _as: ask size
            ///   - bx: bid exchange (Stock quote only)
            ///   - bp: bid price
            ///   - bs: bid size
            ///   - c: quote conditions (Stock quotes only)
            ///   - x: Exchange (Crypto quote Only)
            ///   - z: Tape (Stock quote only)
            public init(
                t: Foundation.Date,
                ax: Swift.String? = nil,
                ap: Swift.Double? = nil,
                _as: Swift.Double? = nil,
                bx: Swift.String? = nil,
                bp: Swift.Double? = nil,
                bs: Swift.Double? = nil,
                c: [Swift.String]? = nil,
                x: Swift.String? = nil,
                z: Swift.String? = nil
            ) {
                self.t = t
                self.ax = ax
                self.ap = ap
                self._as = _as
                self.bx = bx
                self.bp = bp
                self.bs = bs
                self.c = c
                self.x = x
                self.z = z
            }
            public enum CodingKeys: String, CodingKey {
                case t
                case ax
                case ap
                case _as = "as"
                case bx
                case bp
                case bs
                case c
                case x
                case z
            }
        }
        /// The Quotes API provides NBBO quotes for a given ticker symbol at a specified date.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/QuotesResponse`.
        public struct QuotesResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/QuotesResponse/quotes`.
            public var quotes: [Components.Schemas.Quote]?
            /// - Remark: Generated from `#/components/schemas/QuotesResponse/symbol`.
            public var symbol: Swift.String
            /// - Remark: Generated from `#/components/schemas/QuotesResponse/next_page_token`.
            public var next_page_token: Swift.String?
            /// Creates a new `QuotesResponse`.
            ///
            /// - Parameters:
            ///   - quotes:
            ///   - symbol:
            ///   - next_page_token:
            public init(
                quotes: [Components.Schemas.Quote]? = nil,
                symbol: Swift.String,
                next_page_token: Swift.String? = nil
            ) {
                self.quotes = quotes
                self.symbol = symbol
                self.next_page_token = next_page_token
            }
            public enum CodingKeys: String, CodingKey {
                case quotes
                case symbol
                case next_page_token
            }
        }
        /// A model representing the result of hitting the Latest Quote api.
        ///
        /// Represents a single Quote that should be the latest quote data for a given ticker symbol
        ///
        /// - Remark: Generated from `#/components/schemas/LatestQuoteResponse`.
        public struct LatestQuoteResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LatestQuoteResponse/quote`.
            public var quote: Components.Schemas.Quote
            /// - Remark: Generated from `#/components/schemas/LatestQuoteResponse/symbol`.
            public var symbol: Swift.String
            /// Creates a new `LatestQuoteResponse`.
            ///
            /// - Parameters:
            ///   - quote:
            ///   - symbol:
            public init(
                quote: Components.Schemas.Quote,
                symbol: Swift.String
            ) {
                self.quote = quote
                self.symbol = symbol
            }
            public enum CodingKeys: String, CodingKey {
                case quote
                case symbol
            }
        }
        /// A model representing the result of hitting the Multi Quotes api; represents multiple Quotes for multiple symbols.
        ///
        /// Returned results are sorted by symbol first then by Quote timestamp. This means that you are likely to see only one symbol in your first response if there are enough Quotes for that symbol to hit the limit you requested on that request.
        ///
        /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Quotes were found for them.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/MultiQuotesReponse`.
        public struct MultiQuotesReponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/MultiQuotesReponse/quotes`.
            public struct quotesPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: [Components.Schemas.Quote]]
                /// Creates a new `quotesPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: [Components.Schemas.Quote]] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// - Remark: Generated from `#/components/schemas/MultiQuotesReponse/quotes`.
            public var quotes: Components.Schemas.MultiQuotesReponse.quotesPayload
            /// pass this token with your request again to get the next page of results
            ///
            /// - Remark: Generated from `#/components/schemas/MultiQuotesReponse/next_page_token`.
            public var next_page_token: Swift.String?
            /// Creates a new `MultiQuotesReponse`.
            ///
            /// - Parameters:
            ///   - quotes:
            ///   - next_page_token: pass this token with your request again to get the next page of results
            public init(
                quotes: Components.Schemas.MultiQuotesReponse.quotesPayload,
                next_page_token: Swift.String? = nil
            ) {
                self.quotes = quotes
                self.next_page_token = next_page_token
            }
            public enum CodingKeys: String, CodingKey {
                case quotes
                case next_page_token
            }
        }
        /// - Remark: Generated from `#/components/schemas/LatestMultiQuotesResponse`.
        public struct LatestMultiQuotesResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LatestMultiQuotesResponse/quotes`.
            public struct quotesPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Components.Schemas.Quote]
                /// Creates a new `quotesPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Components.Schemas.Quote] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// - Remark: Generated from `#/components/schemas/LatestMultiQuotesResponse/quotes`.
            public var quotes: Components.Schemas.LatestMultiQuotesResponse.quotesPayload
            /// Creates a new `LatestMultiQuotesResponse`.
            ///
            /// - Parameters:
            ///   - quotes:
            public init(quotes: Components.Schemas.LatestMultiQuotesResponse.quotesPayload) {
                self.quotes = quotes
            }
            public enum CodingKeys: String, CodingKey {
                case quotes
            }
        }
        /// The bars API returns aggregate historical data for the requested securities.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/Bar`.
        public struct Bar: Codable, Hashable, Sendable {
            /// Timestamp in RFC-3339 format with nanosecond precision.
            ///
            /// - Remark: Generated from `#/components/schemas/Bar/t`.
            public var t: Foundation.Date
            /// Exchange. Only present on Bars for Crypto symbols
            ///
            /// - Remark: Generated from `#/components/schemas/Bar/x`.
            @frozen public enum xPayload: String, Codable, Hashable, Sendable {
                case FTXU = "FTXU"
                case ERSX = "ERSX"
                case CBSE = "CBSE"
            }
            /// Exchange. Only present on Bars for Crypto symbols
            ///
            /// - Remark: Generated from `#/components/schemas/Bar/x`.
            public var x: Components.Schemas.Bar.xPayload?
            /// Open price
            ///
            /// - Remark: Generated from `#/components/schemas/Bar/o`.
            public var o: Swift.Double
            /// High price.
            ///
            /// - Remark: Generated from `#/components/schemas/Bar/h`.
            public var h: Swift.Double
            /// Low price.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Bar/l`.
            public var l: Swift.Double
            /// Close price.
            ///
            /// - Remark: Generated from `#/components/schemas/Bar/c`.
            public var c: Swift.Double
            /// Volume.
            ///
            /// - Remark: Generated from `#/components/schemas/Bar/v`.
            public var v: Swift.Double
            /// Number of trades.
            ///
            /// - Remark: Generated from `#/components/schemas/Bar/n`.
            public var n: Swift.Int64?
            /// Volume weighted average price.
            ///
            /// - Remark: Generated from `#/components/schemas/Bar/vw`.
            public var vw: Swift.Double?
            /// Creates a new `Bar`.
            ///
            /// - Parameters:
            ///   - t: Timestamp in RFC-3339 format with nanosecond precision.
            ///   - x: Exchange. Only present on Bars for Crypto symbols
            ///   - o: Open price
            ///   - h: High price.
            ///   - l: Low price.
            ///   - c: Close price.
            ///   - v: Volume.
            ///   - n: Number of trades.
            ///   - vw: Volume weighted average price.
            public init(
                t: Foundation.Date,
                x: Components.Schemas.Bar.xPayload? = nil,
                o: Swift.Double,
                h: Swift.Double,
                l: Swift.Double,
                c: Swift.Double,
                v: Swift.Double,
                n: Swift.Int64? = nil,
                vw: Swift.Double? = nil
            ) {
                self.t = t
                self.x = x
                self.o = o
                self.h = h
                self.l = l
                self.c = c
                self.v = v
                self.n = n
                self.vw = vw
            }
            public enum CodingKeys: String, CodingKey {
                case t
                case x
                case o
                case h
                case l
                case c
                case v
                case n
                case vw
            }
        }
        /// - Remark: Generated from `#/components/schemas/BarsResponse`.
        public struct BarsResponse: Codable, Hashable, Sendable {
            /// The array of Bar data
            ///
            /// - Remark: Generated from `#/components/schemas/BarsResponse/bars`.
            public var bars: [Components.Schemas.Bar]
            /// the stock ticker or crypto symbol this set of bar data is for
            ///
            /// - Remark: Generated from `#/components/schemas/BarsResponse/symbol`.
            public var symbol: Swift.String
            /// - Remark: Generated from `#/components/schemas/BarsResponse/next_page_token`.
            public var next_page_token: Swift.String?
            /// Creates a new `BarsResponse`.
            ///
            /// - Parameters:
            ///   - bars: The array of Bar data
            ///   - symbol: the stock ticker or crypto symbol this set of bar data is for
            ///   - next_page_token:
            public init(
                bars: [Components.Schemas.Bar],
                symbol: Swift.String,
                next_page_token: Swift.String? = nil
            ) {
                self.bars = bars
                self.symbol = symbol
                self.next_page_token = next_page_token
            }
            public enum CodingKeys: String, CodingKey {
                case bars
                case symbol
                case next_page_token
            }
        }
        /// A model representing the result of hitting one of the Latest Bar api endpoints.
        ///
        /// Represents a single Bar that should be the latest Bar data for a given ticker symbol
        ///
        /// - Remark: Generated from `#/components/schemas/LatestBarResponse`.
        public struct LatestBarResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LatestBarResponse/symbol`.
            public var symbol: Swift.String
            /// - Remark: Generated from `#/components/schemas/LatestBarResponse/bar`.
            public var bar: Components.Schemas.Bar
            /// Creates a new `LatestBarResponse`.
            ///
            /// - Parameters:
            ///   - symbol:
            ///   - bar:
            public init(
                symbol: Swift.String,
                bar: Components.Schemas.Bar
            ) {
                self.symbol = symbol
                self.bar = bar
            }
            public enum CodingKeys: String, CodingKey {
                case symbol
                case bar
            }
        }
        /// A model representing the result of hitting the Multi Bars api; represents multiple Bars for multiple symbols.
        ///
        /// Returned results are sorted by symbol first then by Bar timestamp. This means that you are likely to see only one symbol in your first response if there are enough Bars in the duration you specified for that symbol to hit the limit you requested on that request.
        ///
        /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Bars were found for them in the timeframe.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/MultiBarsResponse`.
        public struct MultiBarsResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/MultiBarsResponse/bars`.
            public struct barsPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: [Components.Schemas.Bar]]
                /// Creates a new `barsPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: [Components.Schemas.Bar]] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// - Remark: Generated from `#/components/schemas/MultiBarsResponse/bars`.
            public var bars: Components.Schemas.MultiBarsResponse.barsPayload
            /// - Remark: Generated from `#/components/schemas/MultiBarsResponse/next_page_token`.
            public var next_page_token: Swift.String?
            /// Creates a new `MultiBarsResponse`.
            ///
            /// - Parameters:
            ///   - bars:
            ///   - next_page_token:
            public init(
                bars: Components.Schemas.MultiBarsResponse.barsPayload,
                next_page_token: Swift.String? = nil
            ) {
                self.bars = bars
                self.next_page_token = next_page_token
            }
            public enum CodingKeys: String, CodingKey {
                case bars
                case next_page_token
            }
        }
        /// A model representing the result of hitting the Latest Multi Bars api; represents the latest Bars for multiple symbols.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/LatestMultiBarsResponse`.
        public struct LatestMultiBarsResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LatestMultiBarsResponse/bars`.
            public struct barsPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Components.Schemas.Bar]
                /// Creates a new `barsPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Components.Schemas.Bar] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// - Remark: Generated from `#/components/schemas/LatestMultiBarsResponse/bars`.
            public var bars: Components.Schemas.LatestMultiBarsResponse.barsPayload
            /// Creates a new `LatestMultiBarsResponse`.
            ///
            /// - Parameters:
            ///   - bars:
            public init(bars: Components.Schemas.LatestMultiBarsResponse.barsPayload) {
                self.bars = bars
            }
            public enum CodingKeys: String, CodingKey {
                case bars
            }
        }
        /// Model representing a news article from the Alpaca Market Data API
        ///
        /// - Remark: Generated from `#/components/schemas/News`.
        public struct News: Codable, Hashable, Sendable {
            /// News article ID
            ///
            /// - Remark: Generated from `#/components/schemas/News/id`.
            public var id: Swift.Int64
            /// Headline or title of the article
            ///
            /// - Remark: Generated from `#/components/schemas/News/headline`.
            public var headline: Swift.String
            /// Original author of news article
            ///
            /// - Remark: Generated from `#/components/schemas/News/author`.
            public var author: Swift.String
            /// Date article was created (RFC 3339)
            ///
            /// - Remark: Generated from `#/components/schemas/News/created_at`.
            public var created_at: Foundation.Date
            /// Date article was updated (RFC 3339)
            ///
            /// - Remark: Generated from `#/components/schemas/News/updated_at`.
            public var updated_at: Foundation.Date
            /// Summary text for the article (may be first sentence of content)
            ///
            /// - Remark: Generated from `#/components/schemas/News/summary`.
            public var summary: Swift.String
            /// Content of the news article (might contain HTML)
            ///
            /// - Remark: Generated from `#/components/schemas/News/content`.
            public var content: Swift.String
            /// URL of article (if applicable)
            ///
            /// - Remark: Generated from `#/components/schemas/News/url`.
            public var url: Swift.String?
            /// List of images (URLs) related to given article (may be empty)
            ///
            /// - Remark: Generated from `#/components/schemas/News/images`.
            public var images: [Components.Schemas.NewsImage]
            /// List of related or mentioned symbols
            ///
            /// - Remark: Generated from `#/components/schemas/News/symbols`.
            public var symbols: [Swift.String]
            /// Source where the news originated from (e.g. Benzinga)
            ///
            /// - Remark: Generated from `#/components/schemas/News/source`.
            public var source: Swift.String
            /// Creates a new `News`.
            ///
            /// - Parameters:
            ///   - id: News article ID
            ///   - headline: Headline or title of the article
            ///   - author: Original author of news article
            ///   - created_at: Date article was created (RFC 3339)
            ///   - updated_at: Date article was updated (RFC 3339)
            ///   - summary: Summary text for the article (may be first sentence of content)
            ///   - content: Content of the news article (might contain HTML)
            ///   - url: URL of article (if applicable)
            ///   - images: List of images (URLs) related to given article (may be empty)
            ///   - symbols: List of related or mentioned symbols
            ///   - source: Source where the news originated from (e.g. Benzinga)
            public init(
                id: Swift.Int64,
                headline: Swift.String,
                author: Swift.String,
                created_at: Foundation.Date,
                updated_at: Foundation.Date,
                summary: Swift.String,
                content: Swift.String,
                url: Swift.String? = nil,
                images: [Components.Schemas.NewsImage],
                symbols: [Swift.String],
                source: Swift.String
            ) {
                self.id = id
                self.headline = headline
                self.author = author
                self.created_at = created_at
                self.updated_at = updated_at
                self.summary = summary
                self.content = content
                self.url = url
                self.images = images
                self.symbols = symbols
                self.source = source
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case headline
                case author
                case created_at
                case updated_at
                case summary
                case content
                case url
                case images
                case symbols
                case source
            }
        }
        /// A model representing images for news article. simply a url to the image along with a size parameter suggesting the display size of the image
        ///
        /// - Remark: Generated from `#/components/schemas/NewsImage`.
        public struct NewsImage: Codable, Hashable, Sendable {
            /// Possible values for size are thumb, small and large.
            ///
            /// - Remark: Generated from `#/components/schemas/NewsImage/size`.
            @frozen public enum sizePayload: String, Codable, Hashable, Sendable {
                case thumb = "thumb"
                case small = "small"
                case large = "large"
            }
            /// Possible values for size are thumb, small and large.
            ///
            /// - Remark: Generated from `#/components/schemas/NewsImage/size`.
            public var size: Components.Schemas.NewsImage.sizePayload
            /// url to image from news article
            ///
            /// - Remark: Generated from `#/components/schemas/NewsImage/url`.
            public var url: Swift.String
            /// Creates a new `NewsImage`.
            ///
            /// - Parameters:
            ///   - size: Possible values for size are thumb, small and large.
            ///   - url: url to image from news article
            public init(
                size: Components.Schemas.NewsImage.sizePayload,
                url: Swift.String
            ) {
                self.size = size
                self.url = url
            }
            public enum CodingKeys: String, CodingKey {
                case size
                case url
            }
        }
        /// - Remark: Generated from `#/components/schemas/GetNewsResponse`.
        public struct GetNewsResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/GetNewsResponse/news`.
            public var news: [Components.Schemas.News]?
            /// Pagination token for next page
            ///
            /// - Remark: Generated from `#/components/schemas/GetNewsResponse/next_page_token`.
            public var next_page_token: Swift.String?
            /// Creates a new `GetNewsResponse`.
            ///
            /// - Parameters:
            ///   - news:
            ///   - next_page_token: Pagination token for next page
            public init(
                news: [Components.Schemas.News]? = nil,
                next_page_token: Swift.String? = nil
            ) {
                self.news = news
                self.next_page_token = next_page_token
            }
            public enum CodingKeys: String, CodingKey {
                case news
                case next_page_token
            }
        }
        /// XBBO or Cross Best Bid and Offer represents the Best Bid and Offer for an exchange
        ///
        /// - Remark: Generated from `#/components/schemas/XBBO`.
        public struct XBBO: Codable, Hashable, Sendable {
            /// Timestamp in RFC-3339 format with nanosecond precision.
            ///
            /// - Remark: Generated from `#/components/schemas/XBBO/t`.
            public var t: Foundation.Date
            /// Ask exchange.
            ///
            /// - Remark: Generated from `#/components/schemas/XBBO/ax`.
            public var ax: Swift.String
            /// Ask price.
            ///
            /// - Remark: Generated from `#/components/schemas/XBBO/ap`.
            public var ap: Swift.Double
            /// Ask size.
            ///
            /// - Remark: Generated from `#/components/schemas/XBBO/as`.
            public var _as: Swift.Double
            /// Bid exchange.
            ///
            /// - Remark: Generated from `#/components/schemas/XBBO/bx`.
            public var bx: Swift.String
            /// Bid price.
            ///
            /// - Remark: Generated from `#/components/schemas/XBBO/bp`.
            public var bp: Swift.Double
            /// Bid size.
            ///
            /// - Remark: Generated from `#/components/schemas/XBBO/bs`.
            public var bs: Swift.Double
            /// Creates a new `XBBO`.
            ///
            /// - Parameters:
            ///   - t: Timestamp in RFC-3339 format with nanosecond precision.
            ///   - ax: Ask exchange.
            ///   - ap: Ask price.
            ///   - _as: Ask size.
            ///   - bx: Bid exchange.
            ///   - bp: Bid price.
            ///   - bs: Bid size.
            public init(
                t: Foundation.Date,
                ax: Swift.String,
                ap: Swift.Double,
                _as: Swift.Double,
                bx: Swift.String,
                bp: Swift.Double,
                bs: Swift.Double
            ) {
                self.t = t
                self.ax = ax
                self.ap = ap
                self._as = _as
                self.bx = bx
                self.bp = bp
                self.bs = bs
            }
            public enum CodingKeys: String, CodingKey {
                case t
                case ax
                case ap
                case _as = "as"
                case bx
                case bp
                case bs
            }
        }
        /// Represents the Latest XBBO for a crypto symbol that calculates the Best Bid and Offer across multiple exchanges.
        ///
        /// - Remark: Generated from `#/components/schemas/LatestXBBOResponse`.
        public struct LatestXBBOResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LatestXBBOResponse/symbol`.
            public var symbol: Swift.String
            /// - Remark: Generated from `#/components/schemas/LatestXBBOResponse/xbbo`.
            public var xbbo: Components.Schemas.XBBO
            /// Creates a new `LatestXBBOResponse`.
            ///
            /// - Parameters:
            ///   - symbol:
            ///   - xbbo:
            public init(
                symbol: Swift.String,
                xbbo: Components.Schemas.XBBO
            ) {
                self.symbol = symbol
                self.xbbo = xbbo
            }
            public enum CodingKeys: String, CodingKey {
                case symbol
                case xbbo
            }
        }
        /// - Remark: Generated from `#/components/schemas/LatestMultiXBBOResponse`.
        public struct LatestMultiXBBOResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LatestMultiXBBOResponse/xbbos`.
            public struct xbbosPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Components.Schemas.XBBO]
                /// Creates a new `xbbosPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Components.Schemas.XBBO] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// - Remark: Generated from `#/components/schemas/LatestMultiXBBOResponse/xbbos`.
            public var xbbos: Components.Schemas.LatestMultiXBBOResponse.xbbosPayload
            /// Creates a new `LatestMultiXBBOResponse`.
            ///
            /// - Parameters:
            ///   - xbbos:
            public init(xbbos: Components.Schemas.LatestMultiXBBOResponse.xbbosPayload) {
                self.xbbos = xbbos
            }
            public enum CodingKeys: String, CodingKey {
                case xbbos
            }
        }
        /// - Remark: Generated from `#/components/schemas/CryptoSpreadsResponse`.
        public struct CryptoSpreadsResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/CryptoSpreadsResponse/spreads`.
            public struct spreadsPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.Int]
                /// Creates a new `spreadsPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.Int] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// - Remark: Generated from `#/components/schemas/CryptoSpreadsResponse/spreads`.
            public var spreads: Components.Schemas.CryptoSpreadsResponse.spreadsPayload
            /// Creates a new `CryptoSpreadsResponse`.
            ///
            /// - Parameters:
            ///   - spreads:
            public init(spreads: Components.Schemas.CryptoSpreadsResponse.spreadsPayload) {
                self.spreads = spreads
            }
            public enum CodingKeys: String, CodingKey {
                case spreads
            }
        }
        /// Contains list of market movers 
        ///
        /// - Remark: Generated from `#/components/schemas/MarketMoversResponse`.
        public struct MarketMoversResponse: Codable, Hashable, Sendable {
            /// List of top N gainers
            ///
            /// - Remark: Generated from `#/components/schemas/MarketMoversResponse/gainers`.
            public var gainers: [Components.Schemas.MarketMoverAsset]
            /// List of top N losers
            ///
            /// - Remark: Generated from `#/components/schemas/MarketMoversResponse/losers`.
            public var losers: [Components.Schemas.MarketMoverAsset]
            /// Market type (stocks or crypto)
            ///
            /// - Remark: Generated from `#/components/schemas/MarketMoversResponse/market_type`.
            @frozen public enum market_typePayload: String, Codable, Hashable, Sendable {
                case stocks = "stocks"
                case crypto = "crypto"
            }
            /// Market type (stocks or crypto)
            ///
            /// - Remark: Generated from `#/components/schemas/MarketMoversResponse/market_type`.
            public var market_type: Components.Schemas.MarketMoversResponse.market_typePayload
            /// Time the movers where last computed
            ///
            /// - Remark: Generated from `#/components/schemas/MarketMoversResponse/last_updated`.
            public var last_updated: Swift.String
            /// Creates a new `MarketMoversResponse`.
            ///
            /// - Parameters:
            ///   - gainers: List of top N gainers
            ///   - losers: List of top N losers
            ///   - market_type: Market type (stocks or crypto)
            ///   - last_updated: Time the movers where last computed
            public init(
                gainers: [Components.Schemas.MarketMoverAsset],
                losers: [Components.Schemas.MarketMoverAsset],
                market_type: Components.Schemas.MarketMoversResponse.market_typePayload,
                last_updated: Swift.String
            ) {
                self.gainers = gainers
                self.losers = losers
                self.market_type = market_type
                self.last_updated = last_updated
            }
            public enum CodingKeys: String, CodingKey {
                case gainers
                case losers
                case market_type
                case last_updated
            }
        }
        /// Name or source of given news article
        ///
        /// - Remark: Generated from `#/components/schemas/MarketMoverAsset`.
        public struct MarketMoverAsset: Codable, Hashable, Sendable {
            /// Symbol of market moving asset
            ///
            /// - Remark: Generated from `#/components/schemas/MarketMoverAsset/symbol`.
            public var symbol: Swift.String
            /// Percentage difference change for the day
            ///
            /// - Remark: Generated from `#/components/schemas/MarketMoverAsset/percent_change`.
            public var percent_change: Swift.Double
            /// Difference in change for the day
            ///
            /// - Remark: Generated from `#/components/schemas/MarketMoverAsset/change`.
            public var change: Swift.Double
            /// Current price of market moving asset
            ///
            /// - Remark: Generated from `#/components/schemas/MarketMoverAsset/price`.
            public var price: Swift.Double
            /// Creates a new `MarketMoverAsset`.
            ///
            /// - Parameters:
            ///   - symbol: Symbol of market moving asset
            ///   - percent_change: Percentage difference change for the day
            ///   - change: Difference in change for the day
            ///   - price: Current price of market moving asset
            public init(
                symbol: Swift.String,
                percent_change: Swift.Double,
                change: Swift.Double,
                price: Swift.Double
            ) {
                self.symbol = symbol
                self.percent_change = percent_change
                self.change = change
                self.price = price
            }
            public enum CodingKeys: String, CodingKey {
                case symbol
                case percent_change
                case change
                case price
            }
        }
        /// Returns an object representing the exchanges we support. The keys are the short form codes you will see in our responses and the values are their respective full names.
        ///
        /// - Remark: Generated from `#/components/schemas/ExchangesResponse`.
        public struct ExchangesResponse: Codable, Hashable, Sendable {
            /// A container of undocumented properties.
            public var additionalProperties: [String: Swift.String]
            /// Creates a new `ExchangesResponse`.
            ///
            /// - Parameters:
            ///   - additionalProperties: A container of undocumented properties.
            public init(additionalProperties: [String: Swift.String] = .init()) {
                self.additionalProperties = additionalProperties
            }
            public init(from decoder: any Decoder) throws {
                additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
            }
            public func encode(to encoder: any Encoder) throws {
                try encoder.encodeAdditionalProperties(additionalProperties)
            }
        }
    }
    /// Types generated from the `#/components/parameters` section of the OpenAPI document.
    public enum Parameters {
        /// A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
        ///
        /// - Remark: Generated from `#/components/parameters/crypto-exchanges`.
        public typealias crypto_hyphen_exchanges = Swift.String
        /// Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
        ///
        /// - Remark: Generated from `#/components/parameters/crypto-exchange`.
        @frozen public enum crypto_hyphen_exchange: String, Codable, Hashable, Sendable {
            case ERSX = "ERSX"
            case CBSE = "CBSE"
            case FTXU = "FTXU"
        }
        /// The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
        ///
        /// - Remark: Generated from `#/components/parameters/crypto-symbols`.
        public typealias crypto_hyphen_symbols = Swift.String
        /// The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
        ///
        /// - Remark: Generated from `#/components/parameters/crypto-symbol`.
        public typealias crypto_hyphen_symbol = Swift.String
        /// Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour.
        ///
        /// - Remark: Generated from `#/components/parameters/timeframe`.
        public typealias timeframe = Swift.String
        /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
        ///
        /// - Remark: Generated from `#/components/parameters/page_token`.
        public typealias page_token = Swift.String
        /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
        ///
        /// - Remark: Generated from `#/components/parameters/start`.
        public typealias start = Foundation.Date
        /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
        ///
        /// - Remark: Generated from `#/components/parameters/end`.
        public typealias end = Foundation.Date
        /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
        ///
        /// - Remark: Generated from `#/components/parameters/limit`.
        public typealias limit = Swift.Int
        /// The stock ticker symbol to query for.
        ///
        /// - Remark: Generated from `#/components/parameters/stock-symbol`.
        public typealias stock_hyphen_symbol = Swift.String
        /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
        ///
        /// - Remark: Generated from `#/components/parameters/feed`.
        @frozen public enum feed: String, Codable, Hashable, Sendable {
            case iex = "iex"
            case sip = "sip"
            case otc = "otc"
        }
        /// specifies the corporate action adjustment(s) for bars data
        ///
        /// - Remark: Generated from `#/components/parameters/adjustment`.
        @frozen public enum adjustment: String, Codable, Hashable, Sendable {
            case raw = "raw"
            case split = "split"
            case dividend = "dividend"
            case all = "all"
        }
        /// The comma-separated list of stock ticker symbols to query for.
        ///
        /// - Remark: Generated from `#/components/parameters/stock-symbols`.
        public typealias stock_hyphen_symbols = Swift.String
    }
    /// Types generated from the `#/components/requestBodies` section of the OpenAPI document.
    public enum RequestBodies {}
    /// Types generated from the `#/components/responses` section of the OpenAPI document.
    public enum Responses {}
    /// Types generated from the `#/components/headers` section of the OpenAPI document.
    public enum Headers {}
}

/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.
public enum Operations {
    /// Get Bar data for multiple stock symbols
    ///
    /// The Multi Bars API returns aggregate historical data for multiple given ticker symbols over a specified time period.
    ///
    /// Returned results are sorted by symbol first then by Bar timestamp. This means that you are likely to see only one symbol in your first response if there are enough Bars for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Bars were found for them.
    ///
    /// - Remark: HTTP `GET /v2/stocks/bars`.
    /// - Remark: Generated from `#/paths//v2/stocks/bars/get(getBarsForMultipleStockSymbols)`.
    public enum getBarsForMultipleStockSymbols {
        public static let id: Swift.String = "getBarsForMultipleStockSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/bars/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The comma-separated list of stock ticker symbols to query for.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/bars/GET/query/symbols`.
                public var symbols: Components.Parameters.stock_hyphen_symbols
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/bars/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/bars/GET/query/end`.
                public var end: Components.Parameters.end?
                /// Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/bars/GET/query/timeframe`.
                public var timeframe: Components.Parameters.timeframe
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/bars/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/bars/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// - Remark: Generated from `#/components/parameters/adjustment`.
                @frozen public enum adjustment: String, Codable, Hashable, Sendable {
                    case raw = "raw"
                    case split = "split"
                    case dividend = "dividend"
                    case all = "all"
                }
                /// specifies the corporate action adjustment(s) for bars data
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/bars/GET/query/adjustment`.
                public var adjustment: Components.Parameters.adjustment?
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/bars/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - symbols: The comma-separated list of stock ticker symbols to query for.
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - timeframe: Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour.
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///   - adjustment: specifies the corporate action adjustment(s) for bars data
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(
                    symbols: Components.Parameters.stock_hyphen_symbols,
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    timeframe: Components.Parameters.timeframe,
                    limit: Components.Parameters.limit? = nil,
                    page_token: Components.Parameters.page_token? = nil,
                    adjustment: Components.Parameters.adjustment? = nil,
                    feed: Components.Parameters.feed? = nil
                ) {
                    self.symbols = symbols
                    self.start = start
                    self.end = end
                    self.timeframe = timeframe
                    self.limit = limit
                    self.page_token = page_token
                    self.adjustment = adjustment
                    self.feed = feed
                }
            }
            public var query: Operations.getBarsForMultipleStockSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/bars/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getBarsForMultipleStockSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getBarsForMultipleStockSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getBarsForMultipleStockSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getBarsForMultipleStockSymbols.Input.Query,
                headers: Operations.getBarsForMultipleStockSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/bars/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/bars/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.MultiBarsResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.MultiBarsResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getBarsForMultipleStockSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getBarsForMultipleStockSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/bars/get(getBarsForMultipleStockSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getBarsForMultipleStockSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getBarsForMultipleStockSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Latest Bar data for multiple stock symbols
    ///
    /// The Bars API returns aggregate historical data for the requested security. Returns the latest bar data for the queried stock symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/bars/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/bars/latest/get(getLatestBarsForMultipleStockSymbols)`.
    public enum getLatestBarsForMultipleStockSymbols {
        public static let id: Swift.String = "getLatestBarsForMultipleStockSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/bars/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The comma-separated list of stock ticker symbols to query for.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/bars/latest/GET/query/symbols`.
                public var symbols: Components.Parameters.stock_hyphen_symbols
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/bars/latest/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - symbols: The comma-separated list of stock ticker symbols to query for.
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(
                    symbols: Components.Parameters.stock_hyphen_symbols,
                    feed: Components.Parameters.feed? = nil
                ) {
                    self.symbols = symbols
                    self.feed = feed
                }
            }
            public var query: Operations.getLatestBarsForMultipleStockSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/bars/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestBarsForMultipleStockSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestBarsForMultipleStockSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestBarsForMultipleStockSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getLatestBarsForMultipleStockSymbols.Input.Query,
                headers: Operations.getLatestBarsForMultipleStockSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/bars/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/bars/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestMultiBarsResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestMultiBarsResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestBarsForMultipleStockSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestBarsForMultipleStockSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/bars/latest/get(getLatestBarsForMultipleStockSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestBarsForMultipleStockSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestBarsForMultipleStockSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Bars
    ///
    /// The Bars API returns aggregate historical data for the requested security. Returns bars for the queried stock symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/bars`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/bars/get(getBarsForStockSymbol)`.
    public enum getBarsForStockSymbol {
        public static let id: Swift.String = "getBarsForStockSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The stock ticker symbol to query for.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/path/symbol`.
                public var symbol: Components.Parameters.stock_hyphen_symbol
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The stock ticker symbol to query for.
                public init(symbol: Components.Parameters.stock_hyphen_symbol) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getBarsForStockSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/query/end`.
                public var end: Components.Parameters.end?
                /// Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/query/timeframe`.
                public var timeframe: Components.Parameters.timeframe
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// - Remark: Generated from `#/components/parameters/adjustment`.
                @frozen public enum adjustment: String, Codable, Hashable, Sendable {
                    case raw = "raw"
                    case split = "split"
                    case dividend = "dividend"
                    case all = "all"
                }
                /// specifies the corporate action adjustment(s) for bars data
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/query/adjustment`.
                public var adjustment: Components.Parameters.adjustment?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - timeframe: Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour.
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///   - adjustment: specifies the corporate action adjustment(s) for bars data
                public init(
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    timeframe: Components.Parameters.timeframe,
                    limit: Components.Parameters.limit? = nil,
                    page_token: Components.Parameters.page_token? = nil,
                    feed: Components.Parameters.feed? = nil,
                    adjustment: Components.Parameters.adjustment? = nil
                ) {
                    self.start = start
                    self.end = end
                    self.timeframe = timeframe
                    self.limit = limit
                    self.page_token = page_token
                    self.feed = feed
                    self.adjustment = adjustment
                }
            }
            public var query: Operations.getBarsForStockSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getBarsForStockSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getBarsForStockSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getBarsForStockSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getBarsForStockSymbol.Input.Path,
                query: Operations.getBarsForStockSymbol.Input.Query,
                headers: Operations.getBarsForStockSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.BarsResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BarsResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getBarsForStockSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getBarsForStockSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/bars/get(getBarsForStockSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getBarsForStockSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getBarsForStockSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Latest Bars for Symbol
    ///
    /// The Bars API returns aggregate historical data for the requested security. Returns the latest bar data for the queried stock symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/bars/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/bars/latest/get(getLatestBarForStockSymbol)`.
    public enum getLatestBarForStockSymbol {
        public static let id: Swift.String = "getLatestBarForStockSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/latest/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The stock ticker symbol to query for.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/latest/GET/path/symbol`.
                public var symbol: Components.Parameters.stock_hyphen_symbol
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The stock ticker symbol to query for.
                public init(symbol: Components.Parameters.stock_hyphen_symbol) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getLatestBarForStockSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/latest/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(feed: Components.Parameters.feed? = nil) {
                    self.feed = feed
                }
            }
            public var query: Operations.getLatestBarForStockSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestBarForStockSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestBarForStockSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestBarForStockSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getLatestBarForStockSymbol.Input.Path,
                query: Operations.getLatestBarForStockSymbol.Input.Query = .init(),
                headers: Operations.getLatestBarForStockSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/bars/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestBarResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestBarResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestBarForStockSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestBarForStockSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/bars/latest/get(getLatestBarForStockSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestBarForStockSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestBarForStockSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Trade data for multiple stock symbols
    ///
    /// The Multi Trades API provides historical trade data for multiple given ticker symbols over a specified time period.
    ///
    /// Returned results are sorted by symbol first then by Trade timestamp. This means that you are likely to see only one symbol in your first response if there are enough Trades for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Trades were found for them.
    ///
    /// - Remark: HTTP `GET /v2/stocks/trades`.
    /// - Remark: Generated from `#/paths//v2/stocks/trades/get(getTradesForMultipleStockSymbols)`.
    public enum getTradesForMultipleStockSymbols {
        public static let id: Swift.String = "getTradesForMultipleStockSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/trades/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The comma-separated list of stock ticker symbols to query for.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/trades/GET/query/symbols`.
                public var symbols: Components.Parameters.stock_hyphen_symbols
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/trades/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/trades/GET/query/end`.
                public var end: Components.Parameters.end?
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/trades/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/trades/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/trades/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - symbols: The comma-separated list of stock ticker symbols to query for.
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(
                    symbols: Components.Parameters.stock_hyphen_symbols,
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    limit: Components.Parameters.limit? = nil,
                    page_token: Components.Parameters.page_token? = nil,
                    feed: Components.Parameters.feed? = nil
                ) {
                    self.symbols = symbols
                    self.start = start
                    self.end = end
                    self.limit = limit
                    self.page_token = page_token
                    self.feed = feed
                }
            }
            public var query: Operations.getTradesForMultipleStockSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/trades/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTradesForMultipleStockSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTradesForMultipleStockSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getTradesForMultipleStockSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getTradesForMultipleStockSymbols.Input.Query,
                headers: Operations.getTradesForMultipleStockSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/trades/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/trades/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.MultiTradesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.MultiTradesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getTradesForMultipleStockSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getTradesForMultipleStockSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/trades/get(getTradesForMultipleStockSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getTradesForMultipleStockSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getTradesForMultipleStockSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Latest Trades data for multiple stock symbols
    ///
    /// Returns the latest trades data for the queried stock symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/trades/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/trades/latest/get(getLatestTradesForMultipleStockSymbols)`.
    public enum getLatestTradesForMultipleStockSymbols {
        public static let id: Swift.String = "getLatestTradesForMultipleStockSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/trades/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The comma-separated list of stock ticker symbols to query for.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/trades/latest/GET/query/symbols`.
                public var symbols: Components.Parameters.stock_hyphen_symbols
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/trades/latest/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - symbols: The comma-separated list of stock ticker symbols to query for.
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(
                    symbols: Components.Parameters.stock_hyphen_symbols,
                    feed: Components.Parameters.feed? = nil
                ) {
                    self.symbols = symbols
                    self.feed = feed
                }
            }
            public var query: Operations.getLatestTradesForMultipleStockSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/trades/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestTradesForMultipleStockSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestTradesForMultipleStockSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestTradesForMultipleStockSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getLatestTradesForMultipleStockSymbols.Input.Query,
                headers: Operations.getLatestTradesForMultipleStockSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/trades/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/trades/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestMultiTradesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestMultiTradesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestTradesForMultipleStockSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestTradesForMultipleStockSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/trades/latest/get(getLatestTradesForMultipleStockSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestTradesForMultipleStockSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestTradesForMultipleStockSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Trades
    ///
    /// The Trades API provides historical trade data for a given ticker symbol on a specified date. Returns trades for the queried stock signal.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/trades`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/trades/get(getTradesForStockSymbol)`.
    public enum getTradesForStockSymbol {
        public static let id: Swift.String = "getTradesForStockSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The symbol to query for
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/GET/path/symbol`.
                public var symbol: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The symbol to query for
                public init(symbol: Swift.String) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getTradesForStockSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/GET/query/end`.
                public var end: Components.Parameters.end?
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    limit: Components.Parameters.limit? = nil,
                    page_token: Components.Parameters.page_token? = nil,
                    feed: Components.Parameters.feed? = nil
                ) {
                    self.start = start
                    self.end = end
                    self.limit = limit
                    self.page_token = page_token
                    self.feed = feed
                }
            }
            public var query: Operations.getTradesForStockSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTradesForStockSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTradesForStockSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getTradesForStockSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getTradesForStockSymbol.Input.Path,
                query: Operations.getTradesForStockSymbol.Input.Query = .init(),
                headers: Operations.getTradesForStockSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.TradesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.TradesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getTradesForStockSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getTradesForStockSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/trades/get(getTradesForStockSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getTradesForStockSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getTradesForStockSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Latest Trade
    ///
    /// The Latest Trade API provides the latest trade data for a given ticker symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/trades/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/trades/latest/get(getLatestTradeForStockSymbol)`.
    public enum getLatestTradeForStockSymbol {
        public static let id: Swift.String = "getLatestTradeForStockSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/latest/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The symbol to query for
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/latest/GET/path/symbol`.
                public var symbol: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The symbol to query for
                public init(symbol: Swift.String) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getLatestTradeForStockSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/latest/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(feed: Components.Parameters.feed? = nil) {
                    self.feed = feed
                }
            }
            public var query: Operations.getLatestTradeForStockSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestTradeForStockSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestTradeForStockSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestTradeForStockSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getLatestTradeForStockSymbol.Input.Path,
                query: Operations.getLatestTradeForStockSymbol.Input.Query = .init(),
                headers: Operations.getLatestTradeForStockSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/trades/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestTradeResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestTradeResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestTradeForStockSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestTradeForStockSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/trades/latest/get(getLatestTradeForStockSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestTradeForStockSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestTradeForStockSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Quotes for multiple stock symbols
    ///
    /// The Multi Quotes API provides NBBO quotes for multiple given ticker symbols over a specified time period.
    ///
    /// Returned results are sorted by symbol first then by Quote timestamp. This means that you are likely to see only one symbol in your first response if there are enough Quotes for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Quotes were found for them.
    ///
    /// - Remark: HTTP `GET /v2/stocks/quotes`.
    /// - Remark: Generated from `#/paths//v2/stocks/quotes/get(getQuotesForMultipleStockSymbols)`.
    public enum getQuotesForMultipleStockSymbols {
        public static let id: Swift.String = "getQuotesForMultipleStockSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/quotes/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The comma-separated list of stock ticker symbols to query for.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/quotes/GET/query/symbols`.
                public var symbols: Components.Parameters.stock_hyphen_symbols
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/quotes/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/quotes/GET/query/end`.
                public var end: Components.Parameters.end?
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/quotes/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/quotes/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/quotes/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - symbols: The comma-separated list of stock ticker symbols to query for.
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(
                    symbols: Components.Parameters.stock_hyphen_symbols,
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    limit: Components.Parameters.limit? = nil,
                    page_token: Components.Parameters.page_token? = nil,
                    feed: Components.Parameters.feed? = nil
                ) {
                    self.symbols = symbols
                    self.start = start
                    self.end = end
                    self.limit = limit
                    self.page_token = page_token
                    self.feed = feed
                }
            }
            public var query: Operations.getQuotesForMultipleStockSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/quotes/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getQuotesForMultipleStockSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getQuotesForMultipleStockSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getQuotesForMultipleStockSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getQuotesForMultipleStockSymbols.Input.Query,
                headers: Operations.getQuotesForMultipleStockSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/quotes/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/quotes/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.MultiQuotesReponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.MultiQuotesReponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getQuotesForMultipleStockSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getQuotesForMultipleStockSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/quotes/get(getQuotesForMultipleStockSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getQuotesForMultipleStockSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getQuotesForMultipleStockSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Latest Quotes for multiple stock symbols
    ///
    /// Returns the latest quotes data for the queried stock symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/quotes/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/quotes/latest/get(getLatestQuotesForMultipleStockSymbols)`.
    public enum getLatestQuotesForMultipleStockSymbols {
        public static let id: Swift.String = "getLatestQuotesForMultipleStockSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/quotes/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The comma-separated list of stock ticker symbols to query for.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/quotes/latest/GET/query/symbols`.
                public var symbols: Components.Parameters.stock_hyphen_symbols
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/quotes/latest/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - symbols: The comma-separated list of stock ticker symbols to query for.
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(
                    symbols: Components.Parameters.stock_hyphen_symbols,
                    feed: Components.Parameters.feed? = nil
                ) {
                    self.symbols = symbols
                    self.feed = feed
                }
            }
            public var query: Operations.getLatestQuotesForMultipleStockSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/quotes/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestQuotesForMultipleStockSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestQuotesForMultipleStockSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestQuotesForMultipleStockSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getLatestQuotesForMultipleStockSymbols.Input.Query,
                headers: Operations.getLatestQuotesForMultipleStockSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/quotes/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/quotes/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestMultiQuotesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestMultiQuotesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestQuotesForMultipleStockSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestQuotesForMultipleStockSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/quotes/latest/get(getLatestQuotesForMultipleStockSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestQuotesForMultipleStockSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestQuotesForMultipleStockSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Quotes for stock symbol
    ///
    /// The Quotes API provides NBBO quotes for a single given ticker symbol at a specified date. Returns quotes (NBBOs) for the querried stock symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/quotes`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/quotes/get(getQuotesForStockSymbol)`.
    public enum getQuotesForStockSymbol {
        public static let id: Swift.String = "getQuotesForStockSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The symbol to query for
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/GET/path/symbol`.
                public var symbol: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The symbol to query for
                public init(symbol: Swift.String) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getQuotesForStockSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/GET/query/end`.
                public var end: Components.Parameters.end?
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    limit: Components.Parameters.limit? = nil,
                    page_token: Components.Parameters.page_token? = nil,
                    feed: Components.Parameters.feed? = nil
                ) {
                    self.start = start
                    self.end = end
                    self.limit = limit
                    self.page_token = page_token
                    self.feed = feed
                }
            }
            public var query: Operations.getQuotesForStockSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getQuotesForStockSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getQuotesForStockSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getQuotesForStockSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getQuotesForStockSymbol.Input.Path,
                query: Operations.getQuotesForStockSymbol.Input.Query = .init(),
                headers: Operations.getQuotesForStockSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.QuotesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.QuotesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getQuotesForStockSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getQuotesForStockSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/quotes/get(getQuotesForStockSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getQuotesForStockSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getQuotesForStockSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Latest Quote for stock symbol
    ///
    /// The Latest Quote API provides the latest quote data for a given ticker symbol.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/quotes/latest`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/quotes/latest/get(getLatestQuoteForStockSymbol)`.
    public enum getLatestQuoteForStockSymbol {
        public static let id: Swift.String = "getLatestQuoteForStockSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/latest/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The symbol to query for
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/latest/GET/path/symbol`.
                public var symbol: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The symbol to query for
                public init(symbol: Swift.String) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getLatestQuoteForStockSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/latest/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(feed: Components.Parameters.feed? = nil) {
                    self.feed = feed
                }
            }
            public var query: Operations.getLatestQuoteForStockSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestQuoteForStockSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestQuoteForStockSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestQuoteForStockSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getLatestQuoteForStockSymbol.Input.Path,
                query: Operations.getLatestQuoteForStockSymbol.Input.Query = .init(),
                headers: Operations.getLatestQuoteForStockSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/quotes/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestQuoteResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestQuoteResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestQuoteForStockSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestQuoteForStockSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/quotes/latest/get(getLatestQuoteForStockSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestQuoteForStockSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestQuoteForStockSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Snapshots for multiple stock symbols
    ///
    /// The Snapshot API for multiple tickers provides the latest trade, latest quote, minute bar daily bar and previous daily bar data for the given ticker symbols.
    ///
    /// - Remark: HTTP `GET /v2/stocks/snapshots`.
    /// - Remark: Generated from `#/paths//v2/stocks/snapshots/get(getSnapshotsForMultipleStockSymbols)`.
    public enum getSnapshotsForMultipleStockSymbols {
        public static let id: Swift.String = "getSnapshotsForMultipleStockSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/snapshots/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The comma-separated list of stock ticker symbols to query for.
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/snapshots/GET/query/symbols`.
                public var symbols: Components.Parameters.stock_hyphen_symbols
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/snapshots/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - symbols: The comma-separated list of stock ticker symbols to query for.
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(
                    symbols: Components.Parameters.stock_hyphen_symbols,
                    feed: Components.Parameters.feed? = nil
                ) {
                    self.symbols = symbols
                    self.feed = feed
                }
            }
            public var query: Operations.getSnapshotsForMultipleStockSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/snapshots/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getSnapshotsForMultipleStockSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getSnapshotsForMultipleStockSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getSnapshotsForMultipleStockSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getSnapshotsForMultipleStockSymbols.Input.Query,
                headers: Operations.getSnapshotsForMultipleStockSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/snapshots/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/snapshots/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.MultiSnapshotResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.MultiSnapshotResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getSnapshotsForMultipleStockSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getSnapshotsForMultipleStockSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/snapshots/get(getSnapshotsForMultipleStockSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getSnapshotsForMultipleStockSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getSnapshotsForMultipleStockSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a Snapshot for a stock symbol
    ///
    /// The Snapshot API for one ticker provides the latest trade, latest quote, minute bar daily bar and previous daily bar data for a given ticker symbol. This endpoint returns the snapshot for the requested security.
    ///
    /// - Remark: HTTP `GET /v2/stocks/{symbol}/snapshot`.
    /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/snapshot/get(getSnapshotForStockSymbol)`.
    public enum getSnapshotForStockSymbol {
        public static let id: Swift.String = "getSnapshotForStockSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/snapshot/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The symbol to query for
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/snapshot/GET/path/symbol`.
                public var symbol: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The symbol to query for
                public init(symbol: Swift.String) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getSnapshotForStockSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/snapshot/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/feed`.
                @frozen public enum feed: String, Codable, Hashable, Sendable {
                    case iex = "iex"
                    case sip = "sip"
                    case otc = "otc"
                }
                /// Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/snapshot/GET/query/feed`.
                public var feed: Components.Parameters.feed?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - feed: Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription
                public init(feed: Components.Parameters.feed? = nil) {
                    self.feed = feed
                }
            }
            public var query: Operations.getSnapshotForStockSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/snapshot/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getSnapshotForStockSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getSnapshotForStockSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getSnapshotForStockSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getSnapshotForStockSymbol.Input.Path,
                query: Operations.getSnapshotForStockSymbol.Input.Query = .init(),
                headers: Operations.getSnapshotForStockSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/snapshot/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/{symbol}/snapshot/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Snapshot)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Snapshot {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getSnapshotForStockSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getSnapshotForStockSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/{symbol}/snapshot/get(getSnapshotForStockSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getSnapshotForStockSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getSnapshotForStockSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Trade data for multiple crypto symbols
    ///
    /// The Multi Trades API provides historical trade data for a list of given crypto symbols on a specified date. Returns trades for the queried crypto symbols.
    ///
    /// Returned results are sorted by symbol first then by Trade timestamp. This means that you are likely to see only one symbol in your first response if there are enough Trades for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Trades were found for them.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/trades`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/trades/get(getTradesForMultipleCryptoSymbols)`.
    public enum getTradesForMultipleCryptoSymbols {
        public static let id: Swift.String = "getTradesForMultipleCryptoSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/GET/query/end`.
                public var end: Components.Parameters.end?
                /// A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/GET/query/exchanges`.
                public var exchanges: Components.Parameters.crypto_hyphen_exchanges?
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/GET/query/symbols`.
                public var symbols: Components.Parameters.crypto_hyphen_symbols
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - exchanges: A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///   - symbols: The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                public init(
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    exchanges: Components.Parameters.crypto_hyphen_exchanges? = nil,
                    limit: Components.Parameters.limit? = nil,
                    page_token: Components.Parameters.page_token? = nil,
                    symbols: Components.Parameters.crypto_hyphen_symbols
                ) {
                    self.start = start
                    self.end = end
                    self.exchanges = exchanges
                    self.limit = limit
                    self.page_token = page_token
                    self.symbols = symbols
                }
            }
            public var query: Operations.getTradesForMultipleCryptoSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTradesForMultipleCryptoSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTradesForMultipleCryptoSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getTradesForMultipleCryptoSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getTradesForMultipleCryptoSymbols.Input.Query,
                headers: Operations.getTradesForMultipleCryptoSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.MultiTradesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.MultiTradesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getTradesForMultipleCryptoSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getTradesForMultipleCryptoSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/trades/get(getTradesForMultipleCryptoSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getTradesForMultipleCryptoSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getTradesForMultipleCryptoSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Latest Trade data for multiple Crypto symbols
    ///
    /// Provides latest trade data for a list of given crypto symbols. 
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/trades/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/trades/latest/get(getLatestTradesForMultipleCryptoSymbols)`.
    public enum getLatestTradesForMultipleCryptoSymbols {
        public static let id: Swift.String = "getLatestTradesForMultipleCryptoSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/latest/GET/query/symbols`.
                public var symbols: Components.Parameters.crypto_hyphen_symbols
                /// - Remark: Generated from `#/components/parameters/crypto-exchange`.
                @frozen public enum crypto_hyphen_exchange: String, Codable, Hashable, Sendable {
                    case ERSX = "ERSX"
                    case CBSE = "CBSE"
                    case FTXU = "FTXU"
                }
                /// Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/latest/GET/query/exchange`.
                public var exchange: Components.Parameters.crypto_hyphen_exchange
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - symbols: The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///   - exchange: Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                public init(
                    symbols: Components.Parameters.crypto_hyphen_symbols,
                    exchange: Components.Parameters.crypto_hyphen_exchange
                ) {
                    self.symbols = symbols
                    self.exchange = exchange
                }
            }
            public var query: Operations.getLatestTradesForMultipleCryptoSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestTradesForMultipleCryptoSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestTradesForMultipleCryptoSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestTradesForMultipleCryptoSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getLatestTradesForMultipleCryptoSymbols.Input.Query,
                headers: Operations.getLatestTradesForMultipleCryptoSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/trades/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestMultiTradesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestMultiTradesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestTradesForMultipleCryptoSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestTradesForMultipleCryptoSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/trades/latest/get(getLatestTradesForMultipleCryptoSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestTradesForMultipleCryptoSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestTradesForMultipleCryptoSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Trade data for a crypto symbol
    ///
    /// The Trades API provides historical trade data for a given crypto symbol on a specified date. Returns trades for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/trades`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/trades/get(getTradesForCryptoSymbol)`.
    public enum getTradesForCryptoSymbol {
        public static let id: Swift.String = "getTradesForCryptoSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/GET/path/symbol`.
                public var symbol: Components.Parameters.crypto_hyphen_symbol
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                public init(symbol: Components.Parameters.crypto_hyphen_symbol) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getTradesForCryptoSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/GET/query/end`.
                public var end: Components.Parameters.end?
                /// A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/GET/query/exchanges`.
                public var exchanges: Components.Parameters.crypto_hyphen_exchanges?
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - exchanges: A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                public init(
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    exchanges: Components.Parameters.crypto_hyphen_exchanges? = nil,
                    limit: Components.Parameters.limit? = nil,
                    page_token: Components.Parameters.page_token? = nil
                ) {
                    self.start = start
                    self.end = end
                    self.exchanges = exchanges
                    self.limit = limit
                    self.page_token = page_token
                }
            }
            public var query: Operations.getTradesForCryptoSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTradesForCryptoSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTradesForCryptoSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getTradesForCryptoSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getTradesForCryptoSymbol.Input.Path,
                query: Operations.getTradesForCryptoSymbol.Input.Query = .init(),
                headers: Operations.getTradesForCryptoSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.TradesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.TradesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getTradesForCryptoSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getTradesForCryptoSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/trades/get(getTradesForCryptoSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getTradesForCryptoSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getTradesForCryptoSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Latest Trades
    ///
    /// The Latest Trades API provides the latest historical trade data for a given crypto symbol. Returns trades for the queried crypto symbol.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/trades/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/trades/latest/get(getLatestTradesForCryptoSymbol)`.
    public enum getLatestTradesForCryptoSymbol {
        public static let id: Swift.String = "getLatestTradesForCryptoSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/latest/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/latest/GET/path/symbol`.
                public var symbol: Components.Parameters.crypto_hyphen_symbol
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                public init(symbol: Components.Parameters.crypto_hyphen_symbol) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getLatestTradesForCryptoSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/crypto-exchange`.
                @frozen public enum crypto_hyphen_exchange: String, Codable, Hashable, Sendable {
                    case ERSX = "ERSX"
                    case CBSE = "CBSE"
                    case FTXU = "FTXU"
                }
                /// Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/latest/GET/query/exchange`.
                public var exchange: Components.Parameters.crypto_hyphen_exchange
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - exchange: Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                public init(exchange: Components.Parameters.crypto_hyphen_exchange) {
                    self.exchange = exchange
                }
            }
            public var query: Operations.getLatestTradesForCryptoSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestTradesForCryptoSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestTradesForCryptoSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestTradesForCryptoSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getLatestTradesForCryptoSymbol.Input.Path,
                query: Operations.getLatestTradesForCryptoSymbol.Input.Query,
                headers: Operations.getLatestTradesForCryptoSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/trades/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestTradeResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestTradeResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestTradesForCryptoSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestTradesForCryptoSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/trades/latest/get(getLatestTradesForCryptoSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestTradesForCryptoSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestTradesForCryptoSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Bars for multiple Crypto symbols
    ///
    /// returns aggregate historical data for the requested crypto symbols.
    ///
    /// Returned results are sorted by symbol first then by Bar timestamp. This means that you are likely to see only one symbol in your first response if there are enough Bars for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Bars were found for them.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/bars`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/bars/get(getBarsForMultipleCryptoSymbols)`.
    public enum getBarsForMultipleCryptoSymbols {
        public static let id: Swift.String = "getBarsForMultipleCryptoSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/GET/query/symbols`.
                public var symbols: Components.Parameters.crypto_hyphen_symbols
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/GET/query/end`.
                public var end: Components.Parameters.end?
                /// Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/GET/query/timeframe`.
                public var timeframe: Components.Parameters.timeframe
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/GET/query/exchanges`.
                public var exchanges: Components.Parameters.crypto_hyphen_exchanges?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - symbols: The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - timeframe: Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour.
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - exchanges: A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                public init(
                    symbols: Components.Parameters.crypto_hyphen_symbols,
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    timeframe: Components.Parameters.timeframe,
                    page_token: Components.Parameters.page_token? = nil,
                    limit: Components.Parameters.limit? = nil,
                    exchanges: Components.Parameters.crypto_hyphen_exchanges? = nil
                ) {
                    self.symbols = symbols
                    self.start = start
                    self.end = end
                    self.timeframe = timeframe
                    self.page_token = page_token
                    self.limit = limit
                    self.exchanges = exchanges
                }
            }
            public var query: Operations.getBarsForMultipleCryptoSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getBarsForMultipleCryptoSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getBarsForMultipleCryptoSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getBarsForMultipleCryptoSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getBarsForMultipleCryptoSymbols.Input.Query,
                headers: Operations.getBarsForMultipleCryptoSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.MultiBarsResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.MultiBarsResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getBarsForMultipleCryptoSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getBarsForMultipleCryptoSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/bars/get(getBarsForMultipleCryptoSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getBarsForMultipleCryptoSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getBarsForMultipleCryptoSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Latest Bars for multiple Crypto symbols
    ///
    /// returns latest historical data for the requested crypto symbols for a specific exchange
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/bars/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/bars/latest/get(getLatestBarsForMultipleCryptoSymbols)`.
    public enum getLatestBarsForMultipleCryptoSymbols {
        public static let id: Swift.String = "getLatestBarsForMultipleCryptoSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/latest/GET/query/symbols`.
                public var symbols: Components.Parameters.crypto_hyphen_symbols
                /// - Remark: Generated from `#/components/parameters/crypto-exchange`.
                @frozen public enum crypto_hyphen_exchange: String, Codable, Hashable, Sendable {
                    case ERSX = "ERSX"
                    case CBSE = "CBSE"
                    case FTXU = "FTXU"
                }
                /// Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/latest/GET/query/exchange`.
                public var exchange: Components.Parameters.crypto_hyphen_exchange
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - symbols: The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///   - exchange: Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                public init(
                    symbols: Components.Parameters.crypto_hyphen_symbols,
                    exchange: Components.Parameters.crypto_hyphen_exchange
                ) {
                    self.symbols = symbols
                    self.exchange = exchange
                }
            }
            public var query: Operations.getLatestBarsForMultipleCryptoSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestBarsForMultipleCryptoSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestBarsForMultipleCryptoSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestBarsForMultipleCryptoSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getLatestBarsForMultipleCryptoSymbols.Input.Query,
                headers: Operations.getLatestBarsForMultipleCryptoSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/bars/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestMultiBarsResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestMultiBarsResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestBarsForMultipleCryptoSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestBarsForMultipleCryptoSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/bars/latest/get(getLatestBarsForMultipleCryptoSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestBarsForMultipleCryptoSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestBarsForMultipleCryptoSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Bar data for a crypto symbol
    ///
    /// The Bars API returns aggregate historical data for the requested securities.. Returns bars for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/bars`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/bars/get(getBarsForCryptoSymbol)`.
    public enum getBarsForCryptoSymbol {
        public static let id: Swift.String = "getBarsForCryptoSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/GET/path/symbol`.
                public var symbol: Components.Parameters.crypto_hyphen_symbol
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                public init(symbol: Components.Parameters.crypto_hyphen_symbol) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getBarsForCryptoSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/GET/query/end`.
                public var end: Components.Parameters.end?
                /// Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/GET/query/timeframe`.
                public var timeframe: Components.Parameters.timeframe
                /// A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/GET/query/exchanges`.
                public var exchanges: Components.Parameters.crypto_hyphen_exchanges?
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - timeframe: Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour.
                ///   - exchanges: A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                public init(
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    timeframe: Components.Parameters.timeframe,
                    exchanges: Components.Parameters.crypto_hyphen_exchanges? = nil,
                    limit: Components.Parameters.limit? = nil,
                    page_token: Components.Parameters.page_token? = nil
                ) {
                    self.start = start
                    self.end = end
                    self.timeframe = timeframe
                    self.exchanges = exchanges
                    self.limit = limit
                    self.page_token = page_token
                }
            }
            public var query: Operations.getBarsForCryptoSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getBarsForCryptoSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getBarsForCryptoSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getBarsForCryptoSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getBarsForCryptoSymbol.Input.Path,
                query: Operations.getBarsForCryptoSymbol.Input.Query,
                headers: Operations.getBarsForCryptoSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.BarsResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BarsResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getBarsForCryptoSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getBarsForCryptoSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/bars/get(getBarsForCryptoSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getBarsForCryptoSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getBarsForCryptoSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Latest Bar data for a Crypto symbol
    ///
    /// Gets latest historical bar data for the requested crypto symbol for a specific exchange
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/bars/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/bars/latest/get(getLatestBarsForCryptoSymbol)`.
    public enum getLatestBarsForCryptoSymbol {
        public static let id: Swift.String = "getLatestBarsForCryptoSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/latest/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/latest/GET/path/symbol`.
                public var symbol: Components.Parameters.crypto_hyphen_symbol
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                public init(symbol: Components.Parameters.crypto_hyphen_symbol) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getLatestBarsForCryptoSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/crypto-exchange`.
                @frozen public enum crypto_hyphen_exchange: String, Codable, Hashable, Sendable {
                    case ERSX = "ERSX"
                    case CBSE = "CBSE"
                    case FTXU = "FTXU"
                }
                /// Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/latest/GET/query/exchange`.
                public var exchange: Components.Parameters.crypto_hyphen_exchange
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - exchange: Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                public init(exchange: Components.Parameters.crypto_hyphen_exchange) {
                    self.exchange = exchange
                }
            }
            public var query: Operations.getLatestBarsForCryptoSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestBarsForCryptoSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestBarsForCryptoSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestBarsForCryptoSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getLatestBarsForCryptoSymbol.Input.Path,
                query: Operations.getLatestBarsForCryptoSymbol.Input.Query,
                headers: Operations.getLatestBarsForCryptoSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/bars/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestBarResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestBarResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestBarsForCryptoSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestBarsForCryptoSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/bars/latest/get(getLatestBarsForCryptoSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestBarsForCryptoSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestBarsForCryptoSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Quotes for multiple crypto symbols
    ///
    /// The Multi Quotes API provides quotes for a list of given crypto symbols at a specified date. Returns quotes for each of  the queried crypto symbols.
    ///
    /// Returned results are sorted by symbol first then by Quote timestamp. This means that you are likely to see only one symbol in your first response if there are enough Quotes for that symbol to hit the limit you requested on that request.
    ///
    /// In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Quotes were found for them.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/quotes`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/quotes/get(getQuotesForMultipleCryptoSymbols)`.
    public enum getQuotesForMultipleCryptoSymbols {
        public static let id: Swift.String = "getQuotesForMultipleCryptoSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/GET/query/end`.
                public var end: Components.Parameters.end?
                /// A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/GET/query/exchanges`.
                public var exchanges: Components.Parameters.crypto_hyphen_exchanges?
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/GET/query/symbols`.
                public var symbols: Components.Parameters.crypto_hyphen_symbols
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - exchanges: A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///   - symbols: The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                public init(
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    exchanges: Components.Parameters.crypto_hyphen_exchanges? = nil,
                    limit: Components.Parameters.limit? = nil,
                    page_token: Components.Parameters.page_token? = nil,
                    symbols: Components.Parameters.crypto_hyphen_symbols
                ) {
                    self.start = start
                    self.end = end
                    self.exchanges = exchanges
                    self.limit = limit
                    self.page_token = page_token
                    self.symbols = symbols
                }
            }
            public var query: Operations.getQuotesForMultipleCryptoSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getQuotesForMultipleCryptoSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getQuotesForMultipleCryptoSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getQuotesForMultipleCryptoSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getQuotesForMultipleCryptoSymbols.Input.Query,
                headers: Operations.getQuotesForMultipleCryptoSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.MultiQuotesReponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.MultiQuotesReponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getQuotesForMultipleCryptoSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getQuotesForMultipleCryptoSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/quotes/get(getQuotesForMultipleCryptoSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getQuotesForMultipleCryptoSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getQuotesForMultipleCryptoSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Latest Quotes for multiple Crypto symbols
    ///
    /// Provides latest quotes for a list of given crypto symbols.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/quotes/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/quotes/latest/get(getLatestQuotesForMultipleCryptoSymbols)`.
    public enum getLatestQuotesForMultipleCryptoSymbols {
        public static let id: Swift.String = "getLatestQuotesForMultipleCryptoSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/latest/GET/query/symbols`.
                public var symbols: Components.Parameters.crypto_hyphen_symbols
                /// - Remark: Generated from `#/components/parameters/crypto-exchange`.
                @frozen public enum crypto_hyphen_exchange: String, Codable, Hashable, Sendable {
                    case ERSX = "ERSX"
                    case CBSE = "CBSE"
                    case FTXU = "FTXU"
                }
                /// Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/latest/GET/query/exchange`.
                public var exchange: Components.Parameters.crypto_hyphen_exchange
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - symbols: The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///   - exchange: Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                public init(
                    symbols: Components.Parameters.crypto_hyphen_symbols,
                    exchange: Components.Parameters.crypto_hyphen_exchange
                ) {
                    self.symbols = symbols
                    self.exchange = exchange
                }
            }
            public var query: Operations.getLatestQuotesForMultipleCryptoSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestQuotesForMultipleCryptoSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestQuotesForMultipleCryptoSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestQuotesForMultipleCryptoSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getLatestQuotesForMultipleCryptoSymbols.Input.Query,
                headers: Operations.getLatestQuotesForMultipleCryptoSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/quotes/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestMultiQuotesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestMultiQuotesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestQuotesForMultipleCryptoSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestQuotesForMultipleCryptoSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/quotes/latest/get(getLatestQuotesForMultipleCryptoSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestQuotesForMultipleCryptoSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestQuotesForMultipleCryptoSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Quotes for crypto symbol
    ///
    /// The Quotes API provides quotes for a given crypto symbol at a specified date. Returns quotes for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/quotes`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/quotes/get(getQuotesForCryptoSymbol)`.
    public enum getQuotesForCryptoSymbol {
        public static let id: Swift.String = "getQuotesForCryptoSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/GET/path/symbol`.
                public var symbol: Components.Parameters.crypto_hyphen_symbol
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                public init(symbol: Components.Parameters.crypto_hyphen_symbol) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getQuotesForCryptoSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/GET/query/end`.
                public var end: Components.Parameters.end?
                /// A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/GET/query/exchanges`.
                public var exchanges: Components.Parameters.crypto_hyphen_exchanges?
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - exchanges: A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                public init(
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    exchanges: Components.Parameters.crypto_hyphen_exchanges? = nil,
                    limit: Components.Parameters.limit? = nil,
                    page_token: Components.Parameters.page_token? = nil
                ) {
                    self.start = start
                    self.end = end
                    self.exchanges = exchanges
                    self.limit = limit
                    self.page_token = page_token
                }
            }
            public var query: Operations.getQuotesForCryptoSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getQuotesForCryptoSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getQuotesForCryptoSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getQuotesForCryptoSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getQuotesForCryptoSymbol.Input.Path,
                query: Operations.getQuotesForCryptoSymbol.Input.Query = .init(),
                headers: Operations.getQuotesForCryptoSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.QuotesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.QuotesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getQuotesForCryptoSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getQuotesForCryptoSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/quotes/get(getQuotesForCryptoSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getQuotesForCryptoSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getQuotesForCryptoSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Latest Quote
    ///
    /// Returns latest quote for the queried crypto symbol
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/quotes/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/quotes/latest/get(getLatestQuoteForCryptoSymbol)`.
    public enum getLatestQuoteForCryptoSymbol {
        public static let id: Swift.String = "getLatestQuoteForCryptoSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/latest/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/latest/GET/path/symbol`.
                public var symbol: Components.Parameters.crypto_hyphen_symbol
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                public init(symbol: Components.Parameters.crypto_hyphen_symbol) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getLatestQuoteForCryptoSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/crypto-exchange`.
                @frozen public enum crypto_hyphen_exchange: String, Codable, Hashable, Sendable {
                    case ERSX = "ERSX"
                    case CBSE = "CBSE"
                    case FTXU = "FTXU"
                }
                /// Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/latest/GET/query/exchange`.
                public var exchange: Components.Parameters.crypto_hyphen_exchange
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - exchange: Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                public init(exchange: Components.Parameters.crypto_hyphen_exchange) {
                    self.exchange = exchange
                }
            }
            public var query: Operations.getLatestQuoteForCryptoSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestQuoteForCryptoSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestQuoteForCryptoSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestQuoteForCryptoSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getLatestQuoteForCryptoSymbol.Input.Path,
                query: Operations.getLatestQuoteForCryptoSymbol.Input.Query,
                headers: Operations.getLatestQuoteForCryptoSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/quotes/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestQuoteResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestQuoteResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestQuoteForCryptoSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestQuoteForCryptoSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/quotes/latest/get(getLatestQuoteForCryptoSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestQuoteForCryptoSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestQuoteForCryptoSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Snapshots for multiple crypto symbols
    ///
    /// The Multi Snapshot API returns the latest trade, latest quote, minute bar daily bar, and previous daily bar data for list of given crypto symbols.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/snapshots`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/snapshots/get(getSnapshotsForMultipleCryptoSymbols)`.
    public enum getSnapshotsForMultipleCryptoSymbols {
        public static let id: Swift.String = "getSnapshotsForMultipleCryptoSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/snapshots/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/crypto-exchange`.
                @frozen public enum crypto_hyphen_exchange: String, Codable, Hashable, Sendable {
                    case ERSX = "ERSX"
                    case CBSE = "CBSE"
                    case FTXU = "FTXU"
                }
                /// Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/snapshots/GET/query/exchange`.
                public var exchange: Components.Parameters.crypto_hyphen_exchange
                /// The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/snapshots/GET/query/symbols`.
                public var symbols: Components.Parameters.crypto_hyphen_symbols
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - exchange: Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///   - symbols: The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                public init(
                    exchange: Components.Parameters.crypto_hyphen_exchange,
                    symbols: Components.Parameters.crypto_hyphen_symbols
                ) {
                    self.exchange = exchange
                    self.symbols = symbols
                }
            }
            public var query: Operations.getSnapshotsForMultipleCryptoSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/snapshots/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getSnapshotsForMultipleCryptoSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getSnapshotsForMultipleCryptoSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getSnapshotsForMultipleCryptoSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getSnapshotsForMultipleCryptoSymbols.Input.Query,
                headers: Operations.getSnapshotsForMultipleCryptoSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/snapshots/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/snapshots/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.MultiSnapshotResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.MultiSnapshotResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/snapshots/GET/responses/200/content/application\/xml`.
                    case xml(OpenAPIRuntime.HTTPBody)
                    /// The associated value of the enum case if `self` is `.xml`.
                    ///
                    /// - Throws: An error if `self` is not `.xml`.
                    /// - SeeAlso: `.xml`.
                    public var xml: OpenAPIRuntime.HTTPBody {
                        get throws {
                            switch self {
                            case let .xml(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/xml",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/snapshots/GET/responses/200/content/multipartForm`.
                    @frozen public enum multipartFormPayload: Sendable, Hashable {
                        case undocumented(OpenAPIRuntime.MultipartRawPart)
                    }
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/snapshots/GET/responses/200/content/multipart\/form-data`.
                    case multipartForm(OpenAPIRuntime.MultipartBody<Operations.getSnapshotsForMultipleCryptoSymbols.Output.Ok.Body.multipartFormPayload>)
                    /// The associated value of the enum case if `self` is `.multipartForm`.
                    ///
                    /// - Throws: An error if `self` is not `.multipartForm`.
                    /// - SeeAlso: `.multipartForm`.
                    public var multipartForm: OpenAPIRuntime.MultipartBody<Operations.getSnapshotsForMultipleCryptoSymbols.Output.Ok.Body.multipartFormPayload> {
                        get throws {
                            switch self {
                            case let .multipartForm(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "multipart/form-data",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getSnapshotsForMultipleCryptoSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getSnapshotsForMultipleCryptoSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/snapshots/get(getSnapshotsForMultipleCryptoSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getSnapshotsForMultipleCryptoSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getSnapshotsForMultipleCryptoSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case xml
            case multipartForm
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/xml":
                    self = .xml
                case "multipart/form-data":
                    self = .multipartForm
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .xml:
                    return "application/xml"
                case .multipartForm:
                    return "multipart/form-data"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .xml,
                    .multipartForm
                ]
            }
        }
    }
    /// Get a Snapshot for a crypto symbol
    ///
    /// The Snapshot API returns the latest trade, latest quote, minute bar daily bar, and previous daily bar data for a given crypto symbol.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/snapshot`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/snapshot/get(getSnapshotForCryptoSymbol)`.
    public enum getSnapshotForCryptoSymbol {
        public static let id: Swift.String = "getSnapshotForCryptoSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/snapshot/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/snapshot/GET/path/symbol`.
                public var symbol: Components.Parameters.crypto_hyphen_symbol
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                public init(symbol: Components.Parameters.crypto_hyphen_symbol) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getSnapshotForCryptoSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/snapshot/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/crypto-exchange`.
                @frozen public enum crypto_hyphen_exchange: String, Codable, Hashable, Sendable {
                    case ERSX = "ERSX"
                    case CBSE = "CBSE"
                    case FTXU = "FTXU"
                }
                /// Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/snapshot/GET/query/exchange`.
                public var exchange: Components.Parameters.crypto_hyphen_exchange
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - exchange: Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                public init(exchange: Components.Parameters.crypto_hyphen_exchange) {
                    self.exchange = exchange
                }
            }
            public var query: Operations.getSnapshotForCryptoSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/snapshot/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getSnapshotForCryptoSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getSnapshotForCryptoSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getSnapshotForCryptoSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getSnapshotForCryptoSymbol.Input.Path,
                query: Operations.getSnapshotForCryptoSymbol.Input.Query,
                headers: Operations.getSnapshotForCryptoSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/snapshot/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/snapshot/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Snapshot)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Snapshot {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/snapshot/GET/responses/200/content/application\/xml`.
                    case xml(OpenAPIRuntime.HTTPBody)
                    /// The associated value of the enum case if `self` is `.xml`.
                    ///
                    /// - Throws: An error if `self` is not `.xml`.
                    /// - SeeAlso: `.xml`.
                    public var xml: OpenAPIRuntime.HTTPBody {
                        get throws {
                            switch self {
                            case let .xml(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/xml",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getSnapshotForCryptoSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getSnapshotForCryptoSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/snapshot/get(getSnapshotForCryptoSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getSnapshotForCryptoSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getSnapshotForCryptoSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case xml
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/xml":
                    self = .xml
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .xml:
                    return "application/xml"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .xml
                ]
            }
        }
    }
    /// Get Latest XBBO for multiple crypto symbols
    ///
    /// Returns the latest XBBO for a given list crypto symbols that calculates the Best Bid and Offer across multiple exchanges. If exchanges is not specified then only the exchanges that can be traded on Alpaca are included in the calculation.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/xbbos/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/xbbos/latest/get(getLatestXBBOForMultipleCryptoSymbols)`.
    public enum getLatestXBBOForMultipleCryptoSymbols {
        public static let id: Swift.String = "getLatestXBBOForMultipleCryptoSymbols"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/xbbos/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/xbbos/latest/GET/query/symbols`.
                public var symbols: Components.Parameters.crypto_hyphen_symbols
                /// A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/xbbos/latest/GET/query/exchanges`.
                public var exchanges: Components.Parameters.crypto_hyphen_exchanges?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - symbols: The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///   - exchanges: A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                public init(
                    symbols: Components.Parameters.crypto_hyphen_symbols,
                    exchanges: Components.Parameters.crypto_hyphen_exchanges? = nil
                ) {
                    self.symbols = symbols
                    self.exchanges = exchanges
                }
            }
            public var query: Operations.getLatestXBBOForMultipleCryptoSymbols.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/xbbos/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestXBBOForMultipleCryptoSymbols.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestXBBOForMultipleCryptoSymbols.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestXBBOForMultipleCryptoSymbols.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getLatestXBBOForMultipleCryptoSymbols.Input.Query,
                headers: Operations.getLatestXBBOForMultipleCryptoSymbols.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/xbbos/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/xbbos/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestMultiXBBOResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestMultiXBBOResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestXBBOForMultipleCryptoSymbols.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestXBBOForMultipleCryptoSymbols.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/xbbos/latest/get(getLatestXBBOForMultipleCryptoSymbols)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestXBBOForMultipleCryptoSymbols.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestXBBOForMultipleCryptoSymbols.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Latest XBBO for a single crypto symbol
    ///
    /// Returns the XBBO for a crypto symbol that calculates the Best Bid and Offer across multiple exchanges. If exchanges is not specified then only the exchanges that can be traded on Alpaca are included in the calculation.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/{symbol}/xbbo/latest`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/xbbo/latest/get(getLatestXBBOForCryptoSymbol)`.
    public enum getLatestXBBOForCryptoSymbol {
        public static let id: Swift.String = "getLatestXBBOForCryptoSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/xbbo/latest/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/xbbo/latest/GET/path/symbol`.
                public var symbol: Components.Parameters.crypto_hyphen_symbol
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - symbol: The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                public init(symbol: Components.Parameters.crypto_hyphen_symbol) {
                    self.symbol = symbol
                }
            }
            public var path: Operations.getLatestXBBOForCryptoSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/xbbo/latest/GET/query`.
            public struct Query: Sendable, Hashable {
                /// A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                ///
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/xbbo/latest/GET/query/exchanges`.
                public var exchanges: Components.Parameters.crypto_hyphen_exchanges?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - exchanges: A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU`
                public init(exchanges: Components.Parameters.crypto_hyphen_exchanges? = nil) {
                    self.exchanges = exchanges
                }
            }
            public var query: Operations.getLatestXBBOForCryptoSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/xbbo/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestXBBOForCryptoSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLatestXBBOForCryptoSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLatestXBBOForCryptoSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getLatestXBBOForCryptoSymbol.Input.Path,
                query: Operations.getLatestXBBOForCryptoSymbol.Input.Query = .init(),
                headers: Operations.getLatestXBBOForCryptoSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/xbbo/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/{symbol}/xbbo/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LatestXBBOResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LatestXBBOResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLatestXBBOForCryptoSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLatestXBBOForCryptoSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/{symbol}/xbbo/latest/get(getLatestXBBOForCryptoSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLatestXBBOForCryptoSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLatestXBBOForCryptoSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get list of crypto spreads per exchange
    ///
    /// Get list of crypto spreads for the different exchanges Alpaca supports in basis points.
    ///
    /// - Remark: HTTP `GET /v1beta1/crypto/meta/spreads`.
    /// - Remark: Generated from `#/paths//v1beta1/crypto/meta/spreads/get(getCryptoMetaSpreads)`.
    public enum getCryptoMetaSpreads {
        public static let id: Swift.String = "getCryptoMetaSpreads"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/crypto/meta/spreads/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getCryptoMetaSpreads.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getCryptoMetaSpreads.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getCryptoMetaSpreads.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            public init(headers: Operations.getCryptoMetaSpreads.Input.Headers = .init()) {
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/crypto/meta/spreads/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/crypto/meta/spreads/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.CryptoSpreadsResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.CryptoSpreadsResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getCryptoMetaSpreads.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getCryptoMetaSpreads.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//v1beta1/crypto/meta/spreads/get(getCryptoMetaSpreads)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getCryptoMetaSpreads.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getCryptoMetaSpreads.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// News API
    ///
    /// Returns latest news articles across stocks and crypto. By default returns latest 10 news articles.
    ///
    /// - Remark: HTTP `GET /v1beta1/news`.
    /// - Remark: Generated from `#/paths//v1beta1/news/get(getNews)`.
    public enum getNews {
        public static let id: Swift.String = "getNews"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/news/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/news/GET/query/start`.
                public var start: Components.Parameters.start?
                /// Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/news/GET/query/end`.
                public var end: Components.Parameters.end?
                /// The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///
                /// - Remark: Generated from `#/paths/v1beta1/news/GET/query/symbols`.
                public var symbols: Components.Parameters.crypto_hyphen_symbols
                /// Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/news/GET/query/limit`.
                public var limit: Components.Parameters.limit?
                /// - Remark: Generated from `#/paths/v1beta1/news/GET/query/sort`.
                @frozen public enum sortPayload: String, Codable, Hashable, Sendable {
                    case DESC = "DESC"
                    case ASC = "ASC"
                }
                /// Sort articles by updated date. Options: DESC, ASC
                ///
                /// - Remark: Generated from `#/paths/v1beta1/news/GET/query/sort`.
                public var sort: Operations.getNews.Input.Query.sortPayload?
                /// Boolean indicator to include content for news articles (if available)
                ///
                /// - Remark: Generated from `#/paths/v1beta1/news/GET/query/include_content`.
                public var include_content: Swift.Bool?
                /// Boolean indicator to exclude news articles that do not contain content 
                ///
                /// - Remark: Generated from `#/paths/v1beta1/news/GET/query/exclude_contentless`.
                public var exclude_contentless: Swift.Bool?
                /// Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/news/GET/query/page_token`.
                public var page_token: Components.Parameters.page_token?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - start: Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - end: Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted.
                ///   - symbols: The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH
                ///   - limit: Number of data points to return. Must be in range 1-10000, defaults to 1000.
                ///   - sort: Sort articles by updated date. Options: DESC, ASC
                ///   - include_content: Boolean indicator to include content for news articles (if available)
                ///   - exclude_contentless: Boolean indicator to exclude news articles that do not contain content 
                ///   - page_token: Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows.
                public init(
                    start: Components.Parameters.start? = nil,
                    end: Components.Parameters.end? = nil,
                    symbols: Components.Parameters.crypto_hyphen_symbols,
                    limit: Components.Parameters.limit? = nil,
                    sort: Operations.getNews.Input.Query.sortPayload? = nil,
                    include_content: Swift.Bool? = nil,
                    exclude_contentless: Swift.Bool? = nil,
                    page_token: Components.Parameters.page_token? = nil
                ) {
                    self.start = start
                    self.end = end
                    self.symbols = symbols
                    self.limit = limit
                    self.sort = sort
                    self.include_content = include_content
                    self.exclude_contentless = exclude_contentless
                    self.page_token = page_token
                }
            }
            public var query: Operations.getNews.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/news/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getNews.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getNews.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getNews.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.getNews.Input.Query,
                headers: Operations.getNews.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/news/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/news/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.GetNewsResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.GetNewsResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getNews.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getNews.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//v1beta1/news/get(getNews)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getNews.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getNews.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Top Market Movers by Market type
    ///
    /// Returns top market movers for stocks. By default will return top 5 market gainers and losers.
    ///
    /// - Remark: HTTP `GET /v1beta1/screener/{market_type}/movers`.
    /// - Remark: Generated from `#/paths//v1beta1/screener/{market_type}/movers/get(getTopMoversByMarketType)`.
    public enum getTopMoversByMarketType {
        public static let id: Swift.String = "getTopMoversByMarketType"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/screener/{market_type}/movers/GET/path`.
            public struct Path: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/screener/{market_type}/movers/GET/path/market_type`.
                @frozen public enum market_typePayload: String, Codable, Hashable, Sendable {
                    case stocks = "stocks"
                    case crypto = "crypto"
                }
                /// Screen specific market (stocks or crypto)
                ///
                /// - Remark: Generated from `#/paths/v1beta1/screener/{market_type}/movers/GET/path/market_type`.
                public var market_type: Operations.getTopMoversByMarketType.Input.Path.market_typePayload
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - market_type: Screen specific market (stocks or crypto)
                public init(market_type: Operations.getTopMoversByMarketType.Input.Path.market_typePayload) {
                    self.market_type = market_type
                }
            }
            public var path: Operations.getTopMoversByMarketType.Input.Path
            /// - Remark: Generated from `#/paths/v1beta1/screener/{market_type}/movers/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Number of top market movers to fetch (gainers and losers). Will return number top for each. By default 10 gainers and 10 losers.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/screener/{market_type}/movers/GET/query/top`.
                public var top: Swift.Int?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - top: Number of top market movers to fetch (gainers and losers). Will return number top for each. By default 10 gainers and 10 losers.
                public init(top: Swift.Int? = nil) {
                    self.top = top
                }
            }
            public var query: Operations.getTopMoversByMarketType.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/screener/{market_type}/movers/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTopMoversByMarketType.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTopMoversByMarketType.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getTopMoversByMarketType.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getTopMoversByMarketType.Input.Path,
                query: Operations.getTopMoversByMarketType.Input.Query = .init(),
                headers: Operations.getTopMoversByMarketType.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/screener/{market_type}/movers/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/screener/{market_type}/movers/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.MarketMoversResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.MarketMoversResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getTopMoversByMarketType.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getTopMoversByMarketType.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//v1beta1/screener/{market_type}/movers/get(getTopMoversByMarketType)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getTopMoversByMarketType.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getTopMoversByMarketType.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Logo for symbol
    ///
    /// Returns logo image resource for provided symbol.
    ///
    /// - Remark: HTTP `GET /v1beta1/logos/{crypto_or_stock_symbol}`.
    /// - Remark: Generated from `#/paths//v1beta1/logos/{crypto_or_stock_symbol}/get(getLogoForSymbol)`.
    public enum getLogoForSymbol {
        public static let id: Swift.String = "getLogoForSymbol"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1beta1/logos/{crypto_or_stock_symbol}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The crypto or stock symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                ///
                /// - Remark: Generated from `#/paths/v1beta1/logos/{crypto_or_stock_symbol}/GET/path/crypto_or_stock_symbol`.
                public var crypto_or_stock_symbol: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - crypto_or_stock_symbol: The crypto or stock symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC.
                public init(crypto_or_stock_symbol: Swift.String) {
                    self.crypto_or_stock_symbol = crypto_or_stock_symbol
                }
            }
            public var path: Operations.getLogoForSymbol.Input.Path
            /// - Remark: Generated from `#/paths/v1beta1/logos/{crypto_or_stock_symbol}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// If true then the api will generate a placeholder image if no logo was found. Defaults to true
                ///
                /// - Remark: Generated from `#/paths/v1beta1/logos/{crypto_or_stock_symbol}/GET/query/placeholder`.
                public var placeholder: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - placeholder: If true then the api will generate a placeholder image if no logo was found. Defaults to true
                public init(placeholder: Swift.Bool? = nil) {
                    self.placeholder = placeholder
                }
            }
            public var query: Operations.getLogoForSymbol.Input.Query
            /// - Remark: Generated from `#/paths/v1beta1/logos/{crypto_or_stock_symbol}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLogoForSymbol.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLogoForSymbol.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLogoForSymbol.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getLogoForSymbol.Input.Path,
                query: Operations.getLogoForSymbol.Input.Query = .init(),
                headers: Operations.getLogoForSymbol.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1beta1/logos/{crypto_or_stock_symbol}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1beta1/logos/{crypto_or_stock_symbol}/GET/responses/200/content/image\/*`.
                    case image__ast_(OpenAPIRuntime.HTTPBody)
                    /// The associated value of the enum case if `self` is `.image__ast_`.
                    ///
                    /// - Throws: An error if `self` is not `.image__ast_`.
                    /// - SeeAlso: `.image__ast_`.
                    public var image__ast_: OpenAPIRuntime.HTTPBody {
                        get throws {
                            switch self {
                            case let .image__ast_(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLogoForSymbol.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLogoForSymbol.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Returns the requested logo as an image.
            ///
            /// - Remark: Generated from `#/paths//v1beta1/logos/{crypto_or_stock_symbol}/get(getLogoForSymbol)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLogoForSymbol.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLogoForSymbol.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct NotFound: Sendable, Hashable {
                /// Creates a new `NotFound`.
                public init() {}
            }
            /// No Logo was found for this symbol. This code will only be returned if you set `placeholder` to false. Otherwise we will generate a placeholder image for this symbol
            ///
            /// - Remark: Generated from `#/paths//v1beta1/logos/{crypto_or_stock_symbol}/get(getLogoForSymbol)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Operations.getLogoForSymbol.Output.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Operations.getLogoForSymbol.Output.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case image__ast_
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "image/*":
                    self = .image__ast_
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .image__ast_:
                    return "image/*"
                }
            }
            public static var allCases: [Self] {
                [
                    .image__ast_
                ]
            }
        }
    }
    /// Get List of supported exchanges
    ///
    /// Returns a json object representing the exchanges we support. The keys are the short form codes you will see in our responses and the values are their respective full names.
    ///
    /// - Remark: HTTP `GET /v2/stocks/meta/exchanges`.
    /// - Remark: Generated from `#/paths//v2/stocks/meta/exchanges/get(getExchanges)`.
    public enum getExchanges {
        public static let id: Swift.String = "getExchanges"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/meta/exchanges/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getExchanges.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getExchanges.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getExchanges.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            public init(headers: Operations.getExchanges.Input.Headers = .init()) {
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/meta/exchanges/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/meta/exchanges/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ExchangesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ExchangesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getExchanges.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getExchanges.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/meta/exchanges/get(getExchanges)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getExchanges.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getExchanges.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get list of Conditions
    ///
    /// Each feed/exchange uses its own set of codes to identify trade and quote conditions, so the same condition may have a different code depending on the originator of the data.
    ///
    /// See [Our documentation](https://alpaca.markets/docs/market-data/#conditions) for more information
    ///
    /// - Remark: HTTP `GET /v2/stocks/meta/conditions/{type}`.
    /// - Remark: Generated from `#/paths//v2/stocks/meta/conditions/{type}/get(getConditions)`.
    public enum getConditions {
        public static let id: Swift.String = "getConditions"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/stocks/meta/conditions/{type}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/meta/conditions/{type}/GET/path/type`.
                @frozen public enum _typePayload: String, Codable, Hashable, Sendable {
                    case trade = "trade"
                    case quote = "quote"
                }
                /// either "trade" or "quote"
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/meta/conditions/{type}/GET/path/type`.
                public var _type: Operations.getConditions.Input.Path._typePayload
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - _type: either "trade" or "quote"
                public init(_type: Operations.getConditions.Input.Path._typePayload) {
                    self._type = _type
                }
            }
            public var path: Operations.getConditions.Input.Path
            /// - Remark: Generated from `#/paths/v2/stocks/meta/conditions/{type}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/meta/conditions/{type}/GET/query/tape`.
                @frozen public enum tapePayload: String, Codable, Hashable, Sendable {
                    case A = "A"
                    case B = "B"
                    case C = "C"
                }
                /// What kind of conditions to retrieve, "A" and "B" return CTS, where "C" will give you UTP 
                ///
                /// - Remark: Generated from `#/paths/v2/stocks/meta/conditions/{type}/GET/query/tape`.
                public var tape: Operations.getConditions.Input.Query.tapePayload
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - tape: What kind of conditions to retrieve, "A" and "B" return CTS, where "C" will give you UTP 
                public init(tape: Operations.getConditions.Input.Query.tapePayload) {
                    self.tape = tape
                }
            }
            public var query: Operations.getConditions.Input.Query
            /// - Remark: Generated from `#/paths/v2/stocks/meta/conditions/{type}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getConditions.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getConditions.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getConditions.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getConditions.Input.Path,
                query: Operations.getConditions.Input.Query,
                headers: Operations.getConditions.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/stocks/meta/conditions/{type}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/stocks/meta/conditions/{type}/GET/responses/200/content/json`.
                    public struct jsonPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                        /// Creates a new `jsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/paths/v2/stocks/meta/conditions/{type}/GET/responses/200/content/application\/json`.
                    case json(Operations.getConditions.Output.Ok.Body.jsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.getConditions.Output.Ok.Body.jsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getConditions.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getConditions.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// Response is a JSON object mapping a condition to a plain text description
            ///
            /// - Remark: Generated from `#/paths//v2/stocks/meta/conditions/{type}/get(getConditions)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getConditions.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getConditions.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
}
