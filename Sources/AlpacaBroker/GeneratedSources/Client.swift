// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// Open brokerage accounts, enable crypto and stock trading, and manage the ongoing user experience with Alpaca Broker API
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Get all accounts
    ///
    /// Retrieves all accounts found by the query'
    ///
    /// - Remark: HTTP `GET /v1/accounts`.
    /// - Remark: Generated from `#/paths//v1/accounts/get(getAllAccounts)`.
    public func getAllAccounts(_ input: Operations.getAllAccounts.Input) async throws -> Operations.getAllAccounts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAllAccounts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "query",
                    value: input.query.query
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "created_after",
                    value: input.query.created_after
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "created_before",
                    value: input.query.created_before
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "status",
                    value: input.query.status
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "entities",
                    value: input.query.entities
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAllAccounts.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Account].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create an account
    ///
    /// Submit an account application with KYC information. This will create a trading account for the end user. The account status may or may not be ACTIVE immediately and you will receive account status updates on the event API. 
    ///
    /// - Remark: HTTP `POST /v1/accounts`.
    /// - Remark: Generated from `#/paths//v1/accounts/post(createAccount)`.
    public func createAccount(_ input: Operations.createAccount.Input) async throws -> Operations.createAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Account.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createAccount.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 409:
                    return .conflict(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createAccount.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get an account by Id.
    ///
    /// You can query a specific account that you submitted to Alpaca by passing into the query the account_id associated with the account youâ€™re retrieving.
    ///
    ///
    /// - Remark: HTTP `GET /v1/accounts/{account_id}`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/get(getAccount)`.
    public func getAccount(_ input: Operations.getAccount.Input) async throws -> Operations.getAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountExtended.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update an account
    ///
    /// This operation updates account information.
    ///
    /// If all parameters are valid and updates have been made, it returns with status code 200. The response is the account model.
    ///
    /// - Remark: HTTP `PATCH /v1/accounts/{account_id}`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/patch(patchAccount)`.
    public func patchAccount(_ input: Operations.patchAccount.Input) async throws -> Operations.patchAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.patchAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.patchAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountExtended.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.patchAccount.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.patchAccount.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Request to close an account
    ///
    /// This operation closes an active account.
    ///
    /// - Remark: HTTP `DELETE /v1/accounts/{account_id}`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/delete(deleteAccount)`.
    public func deleteAccount(_ input: Operations.deleteAccount.Input) async throws -> Operations.deleteAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Return a list of account documents.
    ///
    /// This endpoint allows you to query all the documents that belong to a certain account. You can filter by date, or type of document.
    ///
    /// - Remark: HTTP `GET /v1/accounts/{account_id}/documents`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/documents/get(getDocsForAccount)`.
    public func getDocsForAccount(_ input: Operations.getDocsForAccount.Input) async throws -> Operations.getDocsForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDocsForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/documents",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start_date",
                    value: input.query.start_date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end_date",
                    value: input.query.end_date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "type",
                    value: input.query._type
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getDocsForAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Document].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getDocsForAccount.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Upload a document to an already existing account
    ///
    /// Upload a document to be attached to an account.
    ///
    /// Documents are binary objects whose contents are encoded in base64. Each encoded content size is limited to 10MB if you use Alpaca for KYCaaS. If you perform your own KYC there are no document size limitations.
    ///
    /// - Remark: HTTP `POST /v1/accounts/{account_id}/documents/upload`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/documents/upload/post(uploadDocToAccount)`.
    public func uploadDocToAccount(_ input: Operations.uploadDocToAccount.Input) async throws -> Operations.uploadDocToAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.uploadDocToAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/documents/upload",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.uploadDocToAccount.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.uploadDocToAccount.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Download a document file that belongs to an account.
    ///
    /// This endpoint allows you to download a document identified by the document_id passed in the header. The returned document is in PDF format.
    ///
    /// The operation returns a pre-signed downloadable link as a redirect with HTTP status code 301 if one is found.
    ///
    ///
    /// - Remark: HTTP `GET /v1/accounts/{account_id}/documents/{document_id}/download`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/documents/{document_id}/download/get(downloadDocFromAccount)`.
    public func downloadDocFromAccount(_ input: Operations.downloadDocFromAccount.Input) async throws -> Operations.downloadDocFromAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.downloadDocFromAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/documents/{}/download",
                    parameters: [
                        input.path.account_id,
                        input.path.document_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 301:
                    return .movedPermanently(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Download a document file directly
    ///
    /// The operation returns a pre-signed downloadable link as a redirect with HTTP status code 301 if one is found.
    ///
    ///
    /// - Remark: HTTP `GET /v1/documents/{document_id}`.
    /// - Remark: Generated from `#/paths//v1/documents/{document_id}/get(downloadDocumentById)`.
    public func downloadDocumentById(_ input: Operations.downloadDocumentById.Input) async throws -> Operations.downloadDocumentById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.downloadDocumentById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/documents/{}",
                    parameters: [
                        input.path.document_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 301:
                    return .movedPermanently(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Retrieve bank relationships for an account
    ///
    /// Retrieves Bank Relationships for an account
    ///
    /// - Remark: HTTP `GET /v1/accounts/{account_id}/recipient_banks`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/recipient_banks/get(getRecipientBanks)`.
    public func getRecipientBanks(_ input: Operations.getRecipientBanks.Input) async throws -> Operations.getRecipientBanks.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getRecipientBanks.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/recipient_banks",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "status",
                    value: input.query.status
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "bank_name",
                    value: input.query.bank_name
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRecipientBanks.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Bank].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a Bank Relationship for an account
    ///
    /// If successful, retrieves Bank Relationships for an account
    ///
    /// - Remark: HTTP `POST /v1/accounts/{account_id}/recipient_banks`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/recipient_banks/post(createRecipientBank)`.
    public func createRecipientBank(_ input: Operations.createRecipientBank.Input) async throws -> Operations.createRecipientBank.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createRecipientBank.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/recipient_banks",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createRecipientBank.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Bank.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 409:
                    return .conflict(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete a Bank Relationship for an account
    ///
    /// If successful, deletes Bank Relationship for an account
    ///
    /// - Remark: HTTP `DELETE /v1/accounts/{account_id}/recipient_banks/{bank_id}`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/recipient_banks/{bank_id}/delete(deleteRecipientBank)`.
    public func deleteRecipientBank(_ input: Operations.deleteRecipientBank.Input) async throws -> Operations.deleteRecipientBank.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteRecipientBank.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/recipient_banks/{}",
                    parameters: [
                        input.path.account_id,
                        input.path.bank_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Return a list of transfers for an account.
    ///
    /// You can query a list of transfers for an account.
    ///
    ///
    /// You can filter requested transfers by values such as direction and status.
    ///
    ///
    /// - Remark: HTTP `GET /v1/accounts/{account_id}/transfers`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/transfers/get(getTransfersForAccount)`.
    public func getTransfersForAccount(_ input: Operations.getTransfersForAccount.Input) async throws -> Operations.getTransfersForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getTransfersForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/transfers",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "offset",
                    value: input.query.offset
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTransfersForAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Transfer].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Request a new transfer
    ///
    /// Create a new transfer to an account to fund it.
    ///
    /// In the sandbox environment, you can instantly deposit to or withdraw from an account with a virtual money amount. In the production environment, this endpoint is used only for requesting an outgoing (withdrawal) wire transfer at this moment. For the wire transfer (in production), you need to create a bank resource first using the Bank API. For more on how to fund an account in sandbox please check out this tutorial [here](https://alpaca.markets/learn/fund-broker-api/).
    ///
    /// - Remark: HTTP `POST /v1/accounts/{account_id}/transfers`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/transfers/post(createTransferForAccount)`.
    public func createTransferForAccount(_ input: Operations.createTransferForAccount.Input) async throws -> Operations.createTransferForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createTransferForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/transfers",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createTransferForAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Transfer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Request to close a transfer
    ///
    /// Request to close a transfer
    ///
    /// - Remark: HTTP `DELETE /v1/accounts/{account_id}/transfers/{transfer_id}`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/transfers/{transfer_id}/delete(deleteTransfer)`.
    public func deleteTransfer(_ input: Operations.deleteTransfer.Input) async throws -> Operations.deleteTransfer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteTransfer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/transfers/{}",
                    parameters: [
                        input.path.account_id,
                        input.path.transfer_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Retrieve account activities
    ///
    /// Returns an array of Activities
    ///
    /// Notes:
    /// * Pagination is handled using the `page_token` and `page_size` parameters.
    /// * `page_token` represents the ID of the end of your current page of results.
    ///   for example if in your first response the id of the last Activiy item returned in the array was `20220203000000000::045b3b8d-c566-4bef-b741-2bf598dd6ae7`, you'd pass that value as `page_token` to get the next page of results
    ///
    /// * If specified with a `direction` of `desc`, for example, the results will end before the activity with the specified ID.
    /// * If specified with a `direction` of `asc`, results will begin with the activity immediately after the one specified.
    /// * `page_size` is the maximum number of entries to return in the response.
    /// * If `date` is not specified, the default and maximum value is 100.
    /// * If `date` is specified, the default behavior is to return all results, and there is no maximum page size.
    ///
    /// - Remark: HTTP `GET /v1/accounts/activities`.
    /// - Remark: Generated from `#/paths//v1/accounts/activities/get(getAccountActivities)`.
    public func getAccountActivities(_ input: Operations.getAccountActivities.Input) async throws -> Operations.getAccountActivities.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountActivities.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/activities",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "account_id",
                    value: input.query.account_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "date",
                    value: input.query.date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "after",
                    value: input.query.after
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountActivities.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Activity].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Retrieve specific account activities
    ///
    /// Retrieves an Array of Activies by type
    ///
    /// Notes:
    /// * Pagination is handled using the `page_token` and `page_size` parameters.
    /// * `page_token` represents the ID of the end of your current page of results.
    ///   for example if in your first response the id of the last Activiy item returned in the array was `20220203000000000::045b3b8d-c566-4bef-b741-2bf598dd6ae7`, you'd pass that value as `page_token` to get the next page of results
    ///
    /// * If specified with a `direction` of `desc`, for example, the results will end before the activity with the specified ID.
    /// * If specified with a `direction` of `asc`, results will begin with the activity immediately after the one specified.
    /// * `page_size` is the maximum number of entries to return in the response.
    /// * If `date` is not specified, the default and maximum value is 100.
    /// * If `date` is specified, the default behavior is to return all results, and there is no maximum page size.
    ///
    /// - Remark: HTTP `GET /v1/accounts/activities/{activity_type}`.
    /// - Remark: Generated from `#/paths//v1/accounts/activities/{activity_type}/get(getAccountActivitiesByType)`.
    public func getAccountActivitiesByType(_ input: Operations.getAccountActivitiesByType.Input) async throws -> Operations.getAccountActivitiesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountActivitiesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/activities/{}",
                    parameters: [
                        input.path.activity_type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "account_id",
                    value: input.query.account_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "date",
                    value: input.query.date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "after",
                    value: input.query.after
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_token",
                    value: input.query.page_token
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountActivitiesByType.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Activity].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Retrieve ACH Relationships for an account
    ///
    /// Returns a list of ACH Relationships for an account
    ///
    /// - Remark: HTTP `GET /v1/accounts/{account_id}/ach_relationships`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/ach_relationships/get(getAccountACHRelationships)`.
    public func getAccountACHRelationships(_ input: Operations.getAccountACHRelationships.Input) async throws -> Operations.getAccountACHRelationships.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountACHRelationships.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/ach_relationships",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "statuses",
                    value: input.query.statuses
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountACHRelationships.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.ACHRelationship].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create an ACH Relationship
    ///
    /// Create a new ACHRelationship for an account
    ///
    /// If successful, will return 200 code with a newly created ACH Relationship entity.
    ///
    /// - Remark: HTTP `POST /v1/accounts/{account_id}/ach_relationships`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/ach_relationships/post(createACHRelationshipForAccount)`.
    public func createACHRelationshipForAccount(_ input: Operations.createACHRelationshipForAccount.Input) async throws -> Operations.createACHRelationshipForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createACHRelationshipForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/ach_relationships",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createACHRelationshipForAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ACHRelationship.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.NotAuthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createACHRelationshipForAccount.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete an existing ACH relationship
    ///
    /// Delete an existing ACH relationship for an account
    ///
    /// - Remark: HTTP `DELETE /v1/accounts/{account_id}/ach_relationships/{ach_relationship_id}`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/ach_relationships/{ach_relationship_id}/delete(deleteACHRelationshipFromAccount)`.
    public func deleteACHRelationshipFromAccount(_ input: Operations.deleteACHRelationshipFromAccount.Input) async throws -> Operations.deleteACHRelationshipFromAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteACHRelationshipFromAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/ach_relationships/{}",
                    parameters: [
                        input.path.account_id,
                        input.path.ach_relationship_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Retrieve trading details for an account.
    ///
    /// As a broker you can view more trading details about your users.
    ///
    /// The response is a Trading Account model.
    ///
    /// - Remark: HTTP `GET /v1/trading/accounts/{account_id}/account`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/account/get(getTradingAccount)`.
    public func getTradingAccount(_ input: Operations.getTradingAccount.Input) async throws -> Operations.getTradingAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getTradingAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/account",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTradingAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TradeAccount.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// List open positions for an account
    ///
    /// List open positions for an account
    ///
    /// - Remark: HTTP `GET /v1/trading/accounts/{account_id}/positions`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/positions/get(getPositionsForAccount)`.
    public func getPositionsForAccount(_ input: Operations.getPositionsForAccount.Input) async throws -> Operations.getPositionsForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPositionsForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/positions",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPositionsForAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Position].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Close All Positions for an Account
    ///
    /// Closes (liquidates) all of the accountâ€™s open long and short positions. A response will be provided for each order that is attempted to be cancelled. If an order is no longer cancelable, the server will respond with status 500 and reject the request.
    ///
    /// - Remark: HTTP `DELETE /v1/trading/accounts/{account_id}/positions`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/positions/delete(closeAllPositionsForAccount)`.
    public func closeAllPositionsForAccount(_ input: Operations.closeAllPositionsForAccount.Input) async throws -> Operations.closeAllPositionsForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.closeAllPositionsForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/positions",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "cancel_orders",
                    value: input.query.cancel_orders
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 207:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.closeAllPositionsForAccount.Output.Code207.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.PositionClosedResponse].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code207(.init(body: body))
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get an Open Position for account by Symbol or AssetId
    ///
    /// Retrieves the accountâ€™s open position for the given symbol or asset_id.
    ///
    /// - Remark: HTTP `GET /v1/trading/accounts/{account_id}/positions/{symbol_or_asset_id}`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/positions/{symbol_or_asset_id}/get(getPositionsForAccountBySymbol)`.
    public func getPositionsForAccountBySymbol(_ input: Operations.getPositionsForAccountBySymbol.Input) async throws -> Operations.getPositionsForAccountBySymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPositionsForAccountBySymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/positions/{}",
                    parameters: [
                        input.path.account_id,
                        input.path.symbol_or_asset_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPositionsForAccountBySymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Position.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Close a Position for an Account
    ///
    /// Closes (liquidates) the accountâ€™s open position for the given symbol. Works for both long and short positions.
    ///
    /// - Remark: HTTP `DELETE /v1/trading/accounts/{account_id}/positions/{symbol_or_asset_id}`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/positions/{symbol_or_asset_id}/delete(closePositionForAccountBySymbol)`.
    public func closePositionForAccountBySymbol(_ input: Operations.closePositionForAccountBySymbol.Input) async throws -> Operations.closePositionForAccountBySymbol.Output {
        try await client.send(
            input: input,
            forOperation: Operations.closePositionForAccountBySymbol.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/positions/{}",
                    parameters: [
                        input.path.account_id,
                        input.path.symbol_or_asset_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "qty",
                    value: input.query.qty
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "percentage",
                    value: input.query.percentage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.closePositionForAccountBySymbol.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Order.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Retrieves a single order for the given order_id.
    ///
    /// Retrieves a single order for the given order_id.
    ///
    /// - Remark: HTTP `GET /v1/trading/accounts/{account_id}/orders/{order_id}`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/orders/{order_id}/get(getOrderForAccount)`.
    public func getOrderForAccount(_ input: Operations.getOrderForAccount.Input) async throws -> Operations.getOrderForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getOrderForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/orders/{}",
                    parameters: [
                        input.path.account_id,
                        input.path.order_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOrderForAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Order.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Replaces a single order with updated parameters
    ///
    /// Replaces a single order with updated parameters. Each parameter overrides the corresponding attribute of the existing order. The other attributes remain the same as the existing order.
    ///
    /// A success return code from a replaced order does NOT guarantee the existing open order has been replaced. If the existing open order is filled before the replacing (new) order reaches the execution venue, the replacing (new) order is rejected, and these events are sent in the trade_updates stream channel found [here in the market data api](https://alpaca.markets/docs/api-references/market-data-api/#order-updates).
    ///
    /// While an order is being replaced, the account's buying power is reduced by the larger of the two orders that have been placed (the old order being replaced, and the newly placed order to replace it). If you are replacing a buy entry order with a higher limit price than the original order, the buying power is calculated based on the newly placed order. If you are replacing it with a lower limit price, the buying power is calculated based on the old order.
    ///
    /// - Remark: HTTP `PATCH /v1/trading/accounts/{account_id}/orders/{order_id}`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/orders/{order_id}/patch(replaceOrderForAccount)`.
    public func replaceOrderForAccount(_ input: Operations.replaceOrderForAccount.Input) async throws -> Operations.replaceOrderForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.replaceOrderForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/orders/{}",
                    parameters: [
                        input.path.account_id,
                        input.path.order_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.replaceOrderForAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Order.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 403:
                    return .forbidden(.init())
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Attempts to cancel an open order.
    ///
    /// Attempts to cancel an open order. If the order is no longer cancelable (for example if the status is "filled"), the server will respond with status 422, and reject the request.
    ///
    /// Upon acceptance of the cancel request, it returns status 204.
    ///
    /// - Remark: HTTP `DELETE /v1/trading/accounts/{account_id}/orders/{order_id}`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/orders/{order_id}/delete(deleteOrderForAccount)`.
    public func deleteOrderForAccount(_ input: Operations.deleteOrderForAccount.Input) async throws -> Operations.deleteOrderForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteOrderForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/orders/{}",
                    parameters: [
                        input.path.account_id,
                        input.path.order_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Retrieves a list of orders for the account, filtered by the supplied query parameters.
    ///
    /// Retrieves a list of orders for the account, filtered by the supplied query parameters.
    ///
    /// Endpoint defaults to open orders if no parameters are provided.
    ///
    /// - Remark: HTTP `GET /v1/trading/accounts/{account_id}/orders`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/orders/get(getAllOrdersForAccount)`.
    public func getAllOrdersForAccount(_ input: Operations.getAllOrdersForAccount.Input) async throws -> Operations.getAllOrdersForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAllOrdersForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/orders",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "status",
                    value: input.query.status
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "after",
                    value: input.query.after
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nested",
                    value: input.query.nested
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbols",
                    value: input.query.symbols
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAllOrdersForAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Order].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create an order for an account.
    ///
    /// Create an order for an account.
    ///
    /// - Remark: HTTP `POST /v1/trading/accounts/{account_id}/orders`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/orders/post(createOrderForAccount)`.
    public func createOrderForAccount(_ input: Operations.createOrderForAccount.Input) async throws -> Operations.createOrderForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createOrderForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/orders",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createOrderForAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Order.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 403:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Attempts to cancel all open orders. A response will be provided for each order that is attempted to be cancelled.
    ///
    /// Attempts to cancel all open orders. A response will be provided for each order that is attempted to be cancelled.
    ///
    /// - Remark: HTTP `DELETE /v1/trading/accounts/{account_id}/orders`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/orders/delete(deleteAllOrdersForAccount)`.
    public func deleteAllOrdersForAccount(_ input: Operations.deleteAllOrdersForAccount.Input) async throws -> Operations.deleteAllOrdersForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteAllOrdersForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/orders",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 207:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteAllOrdersForAccount.Output.Code207.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.OrderClosedResponse].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code207(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Retrieve all assets
    ///
    /// Returns all assets
    ///
    /// - Remark: HTTP `GET /v1/assets`.
    /// - Remark: Generated from `#/paths//v1/assets/get(getAssets)`.
    public func getAssets(_ input: Operations.getAssets.Input) async throws -> Operations.getAssets.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAssets.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/assets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "status",
                    value: input.query.status
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "asset_class",
                    value: input.query.asset_class
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAssets.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Asset].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Retrieve an asset by UUID
    ///
    /// Returns the requested asset, if found
    ///
    /// - Remark: HTTP `GET /v1/assets/{symbol_or_asset_id}`.
    /// - Remark: Generated from `#/paths//v1/assets/{symbol_or_asset_id}/get(getAssetBySymbolOrId)`.
    public func getAssetBySymbolOrId(_ input: Operations.getAssetBySymbolOrId.Input) async throws -> Operations.getAssetBySymbolOrId.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAssetBySymbolOrId.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/assets/{}",
                    parameters: [
                        input.path.symbol_or_asset_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAssetBySymbolOrId.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Asset.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Query market calendar
    ///
    /// The calendar API serves the full list of market days from 1970 to 2029. It can also be queried by specifying a start and/or end time to narrow down the results. In addition to the dates, the response also contains the specific open and close times for the market days, taking into account early closures.
    ///
    /// - Remark: HTTP `GET /v1/calendar`.
    /// - Remark: Generated from `#/paths//v1/calendar/get(queryMarketCalendar)`.
    public func queryMarketCalendar(_ input: Operations.queryMarketCalendar.Input) async throws -> Operations.queryMarketCalendar.Output {
        try await client.send(
            input: input,
            forOperation: Operations.queryMarketCalendar.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/calendar",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start",
                    value: input.query.start
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end",
                    value: input.query.end
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.queryMarketCalendar.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Calendar].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Query market clock
    ///
    /// The Clock API serves the current market timestamp, whether or not the market is currently open, as well as the times of the next market open and close.
    ///
    /// - Remark: HTTP `GET /v1/clock`.
    /// - Remark: Generated from `#/paths//v1/clock/get(queryMarketClock)`.
    public func queryMarketClock(_ input: Operations.queryMarketClock.Input) async throws -> Operations.queryMarketClock.Output {
        try await client.send(
            input: input,
            forOperation: Operations.queryMarketClock.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/clock",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.queryMarketClock.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Clock.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Subscribe to account status events (SSE).
    ///
    /// Events API provide event push as well as historical queries via SSE (server sent events).
    ///
    /// Historical events are streamed immediately if queried, and updates are pushed as events occur.
    ///
    /// Query Params Rules:
    /// - `since` required if `until` specified
    /// - `since_id` required if `until_id` specified
    /// - `since` and `since_id` canâ€™t be used at the same time
    /// Behavior:
    /// - if `since` or `since_id` not specified this will not return any historic data
    /// - if `until` or `until_id` reached stream will end (status 200)
    ///
    /// ---
    ///
    /// Note for people using the clients generated from this OAS spec. Currently OAS-3 doesn't have full support for representing SSE style responses from an API, so if you are using a generated client and don't specify a `since` and `until` there is a good chance the generated clients will hang waiting for the response to end.
    ///
    /// If you require the streaming capabilities we recommend not using the generated clients for this specific usecase until the OAS-3 standards come to a consensus on how to represent this correcting in OAS-3.
    ///
    ///
    /// - Remark: HTTP `GET /v1/events/accounts/status`.
    /// - Remark: Generated from `#/paths//v1/events/accounts/status/get(suscribeToAccountStatusSSE)`.
    public func suscribeToAccountStatusSSE(_ input: Operations.suscribeToAccountStatusSSE.Input) async throws -> Operations.suscribeToAccountStatusSSE.Output {
        try await client.send(
            input: input,
            forOperation: Operations.suscribeToAccountStatusSSE.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/events/accounts/status",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since_id",
                    value: input.query.since_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until_id",
                    value: input.query.until_id
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.suscribeToAccountStatusSSE.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "text/event-stream"
                        ]
                    )
                    switch chosenContentType {
                    case "text/event-stream":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .text_event_hyphen_stream(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Subscribe to journal events (SSE).
    ///
    /// The Events API provides event push as well as historical queries via SSE (server sent events).
    ///
    /// You can listen to journal status updates as they get processed by our backoffice.
    ///
    /// Historical events are streamed immediately if queried, and updates are pushed as events occur.
    ///
    /// Query Params Rules:
    /// - `since` required if `until` specified
    /// - `since_id` required if `until_id` specified
    /// - `since` and `since_id` canâ€™t be used at the same time
    /// Behavior:
    /// - if `since` or `since_id` not specified this will not return any historic data
    /// - if `until` or `until_id` reached stream will end (status 200)
    ///
    /// ---
    ///
    /// Note for people using the clients generated from this OAS spec. Currently OAS-3 doesn't have full support for representing SSE style responses from an API, so if you are using a generated client and don't specify a `since` and `until` there is a good chance the generated clients will hang waiting for the response to end.
    ///
    /// If you require the streaming capabilities we recommend not using the generated clients for this specific usecase until the OAS-3 standards come to a consensus on how to represent this correcting in OAS-3.
    ///
    /// - Remark: HTTP `GET /v1/events/journals/status`.
    /// - Remark: Generated from `#/paths//v1/events/journals/status/get(subscribeToJournalStatusSSE)`.
    public func subscribeToJournalStatusSSE(_ input: Operations.subscribeToJournalStatusSSE.Input) async throws -> Operations.subscribeToJournalStatusSSE.Output {
        try await client.send(
            input: input,
            forOperation: Operations.subscribeToJournalStatusSSE.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/events/journals/status",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since_id",
                    value: input.query.since_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until_id",
                    value: input.query.until_id
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.subscribeToJournalStatusSSE.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "text/event-stream"
                        ]
                    )
                    switch chosenContentType {
                    case "text/event-stream":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .text_event_hyphen_stream(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Subscribe to Transfer Events (SSE)
    ///
    /// The Events API provides event push as well as historical queries via SSE (server sent events).
    ///
    /// You can listen to transfer status updates as they get processed by our backoffice, for both end-user and firm accounts.
    ///
    /// Historical events are streamed immediately if queried, and updates are pushed as events occur.
    ///
    /// Query Params Rules:
    /// - `since` required if `until` specified
    /// - `since_id` required if `until_id` specified
    /// - `since` and `since_id` canâ€™t be used at the same time
    /// Behavior:
    /// - if `since` or `since_id` not specified this will not return any historic data
    /// - if `until` or `until_id` reached stream will end (status 200)
    ///
    /// ---
    ///
    /// Note for people using the clients generated from this OAS spec. Currently OAS-3 doesn't have full support for representing SSE style responses from an API, so if you are using a generated client and don't specify a `since` and `until` there is a good chance the generated clients will hang waiting for the response to end.
    ///
    /// If you require the streaming capabilities we recommend not using the generated clients for this specific usecase until the OAS-3 standards come to a consensus on how to represent this correcting in OAS-3.
    ///
    /// - Remark: HTTP `GET /v1/events/transfers/status`.
    /// - Remark: Generated from `#/paths//v1/events/transfers/status/get(subscribeToTransferStatusSSE)`.
    public func subscribeToTransferStatusSSE(_ input: Operations.subscribeToTransferStatusSSE.Input) async throws -> Operations.subscribeToTransferStatusSSE.Output {
        try await client.send(
            input: input,
            forOperation: Operations.subscribeToTransferStatusSSE.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/events/transfers/status",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since_id",
                    value: input.query.since_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until_id",
                    value: input.query.until_id
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.subscribeToTransferStatusSSE.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "text/event-stream"
                        ]
                    )
                    switch chosenContentType {
                    case "text/event-stream":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .text_event_hyphen_stream(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Subscribe to Trade Events (SSE)
    ///
    /// The Events API provides event push as well as historical queries via SSE (server sent events).
    ///
    /// You can listen to events related to trade updates. Most market trades sent during market hours are filled instantly; you can listen to limit order updates through this endpoint.
    ///
    /// Historical events are streamed immediately if queried, and updates are pushed as events occur.
    ///
    /// Query Params Rules:
    /// - `since` required if `until` specified
    /// - `since_id` required if `until_id` specified
    /// - `since` and `since_id` canâ€™t be used at the same time
    /// Behavior:
    /// - if `since` or `since_id` not specified this will not return any historic data
    /// - if `until` or `until_id` reached stream will end (status 200)
    ///
    /// ---
    ///
    /// Note for people using the clients generated from this OAS spec. Currently OAS-3 doesn't have full support for representing SSE style responses from an API, so if you are using a generated client and don't specify a `since` and `until` there is a good chance the generated clients will hang waiting for the response to end.
    ///
    /// If you require the streaming capabilities we recommend not using the generated clients for this specific usecase until the OAS-3 standards come to a consensus on how to represent this correcting in OAS-3.
    ///
    /// - Remark: HTTP `GET /v1/events/trades`.
    /// - Remark: Generated from `#/paths//v1/events/trades/get(subscribeToTradeSSE)`.
    public func subscribeToTradeSSE(_ input: Operations.subscribeToTradeSSE.Input) async throws -> Operations.subscribeToTradeSSE.Output {
        try await client.send(
            input: input,
            forOperation: Operations.subscribeToTradeSSE.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/events/trades",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since_id",
                    value: input.query.since_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until_id",
                    value: input.query.until_id
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.subscribeToTradeSSE.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "text/event-stream"
                        ]
                    )
                    switch chosenContentType {
                    case "text/event-stream":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .text_event_hyphen_stream(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Return a list of requested journals.
    ///
    /// Returns an array of journal objects.
    ///
    /// - Remark: HTTP `GET /v1/journals`.
    /// - Remark: Generated from `#/paths//v1/journals/get(getAllJournals)`.
    public func getAllJournals(_ input: Operations.getAllJournals.Input) async throws -> Operations.getAllJournals.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAllJournals.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/journals",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "after",
                    value: input.query.after
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "before",
                    value: input.query.before
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "status",
                    value: input.query.status
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "entry_type",
                    value: input.query.entry_type
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "to_account",
                    value: input.query.to_account
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "from_account",
                    value: input.query.from_account
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAllJournals.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Journal].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a Journal.
    ///
    /// A journal can be JNLC (move cash) or JNLS (move shares), dictated by `entry_type`. Generally, journal requests are subject to approval and starts from the `pending` status. The status changes are propagated through the Event API. Under certain conditions agreed for the partner, such journal transactions that meet the criteria are executed right away.
    ///
    ///
    /// - Remark: HTTP `POST /v1/journals`.
    /// - Remark: Generated from `#/paths//v1/journals/post(createJournal)`.
    public func createJournal(_ input: Operations.createJournal.Input) async throws -> Operations.createJournal.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createJournal.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/journals",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createJournal.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Journal.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createJournal.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 403:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createJournal.Output.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createJournal.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancel a pending journal.
    ///
    /// You can only delete a journal if the journal is still in a pending state, if a journal is executed you will not be able to delete. The alternative is to create a mirror journal entry to reverse the flow of funds.
    ///
    /// - Remark: HTTP `DELETE /v1/journals/{journal_id}`.
    /// - Remark: Generated from `#/paths//v1/journals/{journal_id}/delete(deleteJournalById)`.
    public func deleteJournalById(_ input: Operations.deleteJournalById.Input) async throws -> Operations.deleteJournalById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteJournalById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/journals/{}",
                    parameters: [
                        input.path.journal_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 404:
                    return .notFound(.init())
                case 422:
                    return .unprocessableContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a Batch Journal Transaction (One-to-Many)
    ///
    /// You can create a batch of journal requests by using this endpoint. This is enabled on JNLC type Journals for now only.
    ///
    /// Every single request must be valid for the entire batch operation to succeed.
    ///
    /// In the case of a successful request, the response will contain an array of journal objects with an extra attribute error_message in the case when a specific account fails to receive a journal.
    ///
    /// - Remark: HTTP `POST /v1/journals/batch`.
    /// - Remark: Generated from `#/paths//v1/journals/batch/post(createBatchJournal)`.
    public func createBatchJournal(_ input: Operations.createBatchJournal.Input) async throws -> Operations.createBatchJournal.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createBatchJournal.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/journals/batch",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createBatchJournal.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.BatchJournalResponse].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get an OAuth client
    ///
    /// The endpoint returns the details of OAuth client to display in the authorization page.
    ///
    ///
    /// - Remark: HTTP `GET /v1/oauth/clients/{client_id}`.
    /// - Remark: Generated from `#/paths//v1/oauth/clients/{client_id}/get(getOAuthClient)`.
    public func getOAuthClient(_ input: Operations.getOAuthClient.Input) async throws -> Operations.getOAuthClient.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getOAuthClient.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/oauth/clients/{}",
                    parameters: [
                        input.path.client_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "response_type",
                    value: input.query.response_type
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "redirect_uri",
                    value: input.query.redirect_uri
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "scope",
                    value: input.query.scope
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOAuthClient.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.OathClientResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOAuthClient.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Issue an OAuth token.
    ///
    /// The operation issues an OAuth code which can be used in the OAuth code flow.
    ///
    ///
    /// - Remark: HTTP `POST /v1/oauth/token`.
    /// - Remark: Generated from `#/paths//v1/oauth/token/post(issueOAuthToken)`.
    public func issueOAuthToken(_ input: Operations.issueOAuthToken.Input) async throws -> Operations.issueOAuthToken.Output {
        try await client.send(
            input: input,
            forOperation: Operations.issueOAuthToken.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/oauth/token",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.issueOAuthToken.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IssueOAuthTokenResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.issueOAuthToken.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.issueOAuthToken.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Authorize an OAuth Token
    ///
    /// The operation issues an OAuth code which can be used in the OAuth code flow.
    ///
    ///
    /// - Remark: HTTP `POST /v1/oauth/authorize`.
    /// - Remark: Generated from `#/paths//v1/oauth/authorize/post(authorizeOAuthToken)`.
    public func authorizeOAuthToken(_ input: Operations.authorizeOAuthToken.Input) async throws -> Operations.authorizeOAuthToken.Output {
        try await client.send(
            input: input,
            forOperation: Operations.authorizeOAuthToken.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/oauth/authorize",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.authorizeOAuthToken.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AuthorizeOAuthTokenResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.authorizeOAuthToken.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.authorizeOAuthToken.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Retrieve all watchlists
    ///
    /// Fetch a list of all watchlists currently in an account.
    ///
    /// - Remark: HTTP `GET /v1/trading/accounts/{account_id}/watchlists`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/watchlists/get(getAllWatchlistsForAccount)`.
    public func getAllWatchlistsForAccount(_ input: Operations.getAllWatchlistsForAccount.Input) async throws -> Operations.getAllWatchlistsForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAllWatchlistsForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/watchlists",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAllWatchlistsForAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Watchlist].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a new watchlist
    ///
    /// Returns the watchlist object
    ///
    /// - Remark: HTTP `POST /v1/trading/accounts/{account_id}/watchlists`.
    /// - Remark: Generated from `#/paths//v1/trading/accounts/{account_id}/watchlists/post(createWatchlistForAccount)`.
    public func createWatchlistForAccount(_ input: Operations.createWatchlistForAccount.Input) async throws -> Operations.createWatchlistForAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createWatchlistForAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/trading/accounts/{}/watchlists",
                    parameters: [
                        input.path.account_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createWatchlistForAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Watchlist.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Manage watchlists
    ///
    /// Fetch a single watchlist by identifier.
    ///
    /// - Remark: HTTP `GET /v1/accounts/{account_id}/watchlists/{watchlist_id}`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/watchlists/{watchlist_id}/get(getWatchlistForAccountById)`.
    public func getWatchlistForAccountById(_ input: Operations.getWatchlistForAccountById.Input) async throws -> Operations.getWatchlistForAccountById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getWatchlistForAccountById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/watchlists/{}",
                    parameters: [
                        input.path.account_id,
                        input.path.watchlist_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getWatchlistForAccountById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Watchlist.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update an existing watchlist
    ///
    /// Replace entirely the set of securities contained in the watchlist while optionally renaming it. Destructive operation.
    ///
    /// - Remark: HTTP `PUT /v1/accounts/{account_id}/watchlists/{watchlist_id}`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/watchlists/{watchlist_id}/put(replaceWatchlistForAccountById)`.
    public func replaceWatchlistForAccountById(_ input: Operations.replaceWatchlistForAccountById.Input) async throws -> Operations.replaceWatchlistForAccountById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.replaceWatchlistForAccountById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/watchlists/{}",
                    parameters: [
                        input.path.account_id,
                        input.path.watchlist_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.replaceWatchlistForAccountById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Watchlist.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Remove a watchlist
    ///
    /// Irrevocably delete a watchlist.
    ///
    /// - Remark: HTTP `DELETE /v1/accounts/{account_id}/watchlists/{watchlist_id}`.
    /// - Remark: Generated from `#/paths//v1/accounts/{account_id}/watchlists/{watchlist_id}/delete(deleteWatchlistFromAccountById)`.
    public func deleteWatchlistFromAccountById(_ input: Operations.deleteWatchlistFromAccountById.Input) async throws -> Operations.deleteWatchlistFromAccountById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteWatchlistFromAccountById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/accounts/{}/watchlists/{}",
                    parameters: [
                        input.path.account_id,
                        input.path.watchlist_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Retrieving Announcements
    ///
    /// This enables searching for an array of corporate action announcements based on criteria.
    ///
    /// - Remark: HTTP `GET /v1/corporate_actions/announcements`.
    /// - Remark: Generated from `#/paths//v1/corporate_actions/announcements/get(getCorporateAnnouncements)`.
    public func getCorporateAnnouncements(_ input: Operations.getCorporateAnnouncements.Input) async throws -> Operations.getCorporateAnnouncements.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getCorporateAnnouncements.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/corporate_actions/announcements",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ca_types",
                    value: input.query.ca_types
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "symbol",
                    value: input.query.symbol
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "cusip",
                    value: input.query.cusip
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "date_type",
                    value: input.query.date_type
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getCorporateAnnouncements.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Announcement].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
